{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ethereum Smart Contract Security Best Practices \u00b6 This document provides a baseline knowledge of security considerations for intermediate Solidity programmers. It is maintained by ConsenSys Diligence , with contributions from our friends in the broader Ethereum community. Our amazing community has also provided translations in Chinese and Vietnamese . Where to start? \u00b6 General Philosophy describes the smart contract security mindset Development Recommendations contains examples of good code patterns Known Attacks describes the different classes of vulnerabilities to avoid Security Tools lists tools for improving code quality, and detecting vulnerabilities Bug Bounties List of bug bounties in the ecosystem. Tip This guideline is updated often, however, if you want to stay on top of the Smart Contract security news and developments sign up for the bi-weekly Smart Contract Security Newsletter . Contributions are welcome! \u00b6 Feel free to submit a pull request, with anything from small fixes, to full new sections. If you are writing new content, please reference the contributing page for guidance on style. See the issues for topics that need to be covered or updated.","title":"Home"},{"location":"#ethereum-smart-contract-security-best-practices","text":"This document provides a baseline knowledge of security considerations for intermediate Solidity programmers. It is maintained by ConsenSys Diligence , with contributions from our friends in the broader Ethereum community. Our amazing community has also provided translations in Chinese and Vietnamese .","title":"Ethereum Smart Contract Security Best Practices"},{"location":"#where-to-start","text":"General Philosophy describes the smart contract security mindset Development Recommendations contains examples of good code patterns Known Attacks describes the different classes of vulnerabilities to avoid Security Tools lists tools for improving code quality, and detecting vulnerabilities Bug Bounties List of bug bounties in the ecosystem. Tip This guideline is updated often, however, if you want to stay on top of the Smart Contract security news and developments sign up for the bi-weekly Smart Contract Security Newsletter .","title":"Where to start?"},{"location":"#contributions-are-welcome","text":"Feel free to submit a pull request, with anything from small fixes, to full new sections. If you are writing new content, please reference the contributing page for guidance on style. See the issues for topics that need to be covered or updated.","title":"Contributions are welcome!"},{"location":"bug-bounty-programs/","text":"Over the course of time Ethereum security has evolved to include different flavours of bug bounty programs which will be detailed below: Bug Bounty Platforms \u00b6 The first category are bug bounty platforms wherein a development team submits their project to a platform that either manages the programme for them or simply lists their project for exposure and reach toward interested security researchers. These platforms are further divided by type. The first are web3 native platforms hosting the majority of smart contract and frontend bug bounty programmes you'll find and the second are traditional platforms hosting majorly programmes with the frontend of centralized exchanges in scope. Finally, there are bounty collaboration platforms where developers are paid to code and implement new features or smart contracts. Web3 native platforms: Immunefi HackenProof Traditional platforms: HackerOne Bugcrowd Bounty collaboration platforms: Gitcoin Crowd-sourced Security Solutions \u00b6 In response to the high demand and low supply for professional smart contract security review firms, a few crowd sourced solutions have emerged to solve the issue. They all employ a bug bounty-esque model hence inclusion on this list. They call them \"audit contests\" with freelance security researchers scrambling to find and report vulnerabilities within a set time period i.e two weeks with payouts only being issued for successful findings. Examples are listed below: Code4rena Project Managed Bounties \u00b6 The final category for now consists of bug bounty programmes that are directly managed by the project team itself and are often focused on smart contracts in their scope whether that's contributing to their features or breaking them. Issues and PRs are welcome to add new bounties, or remove those which are no longer active. Airswap Ethereum Foundation : Has a large scope, including clients, Solidity and Vyper, and more. Etherscan.io ImmutableSoft 0xProject Parity : Includes client and contract code","title":"Bug Bounty Programs"},{"location":"bug-bounty-programs/#bug-bounty-platforms","text":"The first category are bug bounty platforms wherein a development team submits their project to a platform that either manages the programme for them or simply lists their project for exposure and reach toward interested security researchers. These platforms are further divided by type. The first are web3 native platforms hosting the majority of smart contract and frontend bug bounty programmes you'll find and the second are traditional platforms hosting majorly programmes with the frontend of centralized exchanges in scope. Finally, there are bounty collaboration platforms where developers are paid to code and implement new features or smart contracts. Web3 native platforms: Immunefi HackenProof Traditional platforms: HackerOne Bugcrowd Bounty collaboration platforms: Gitcoin","title":"Bug Bounty Platforms"},{"location":"bug-bounty-programs/#crowd-sourced-security-solutions","text":"In response to the high demand and low supply for professional smart contract security review firms, a few crowd sourced solutions have emerged to solve the issue. They all employ a bug bounty-esque model hence inclusion on this list. They call them \"audit contests\" with freelance security researchers scrambling to find and report vulnerabilities within a set time period i.e two weeks with payouts only being issued for successful findings. Examples are listed below: Code4rena","title":"Crowd-sourced Security Solutions"},{"location":"bug-bounty-programs/#project-managed-bounties","text":"The final category for now consists of bug bounty programmes that are directly managed by the project team itself and are often focused on smart contracts in their scope whether that's contributing to their features or breaking them. Issues and PRs are welcome to add new bounties, or remove those which are no longer active. Airswap Ethereum Foundation : Has a large scope, including clients, Solidity and Vyper, and more. Etherscan.io ImmutableSoft 0xProject Parity : Includes client and contract code","title":"Project Managed Bounties"},{"location":"about/","text":"We welcome all contributions - send a pull request or open an issue. When possible, send different pull requests by section/topic. Feel free to peruse the open issues for ideas which need to be expanded on a bit here. Editing and Submitting changes \u00b6 Fork the repo Make changes to the markdown files in the docs/ directory of the master branch Submit a Pull Request Audience \u00b6 Write for an intermediate Ethereum developer, they know the basics of Solidity programming and have coded a number of contracts Style Guidelines \u00b6 General \u00b6 Favor succinctness in writing Use max 3-4 sentences in a section (exceptions can be made when critical) Show, don\u2019t tell (examples speak more than lengthy exposition) Include a simple, illustrative example rather than complex examples that require substantial, extraneous reading Add a source link to the original document when available Create new sections when warranted Keep code lines under 80 characters when possible Mark code as insecure, bad, good where relevant Use the format of the Airbnb Javascript Style guide as a starting point Recommendations Section \u00b6 Always favor a declarative tip starting with a verb for the section title Include good and bad examples, when possible Ensure each subsection has an anchor tag for future hyperlinking Attacks Section \u00b6 Provide an example - then point to a recommendation for the solution in the relevant section of the doc List first/most visible attack, where possible Ensure each subsection has an anchor tag for future hyperlinking Mark vulnerable pieces of code as // INSECURE","title":"Index"},{"location":"about/#editing-and-submitting-changes","text":"Fork the repo Make changes to the markdown files in the docs/ directory of the master branch Submit a Pull Request","title":"Editing and Submitting changes"},{"location":"about/#audience","text":"Write for an intermediate Ethereum developer, they know the basics of Solidity programming and have coded a number of contracts","title":"Audience"},{"location":"about/#style-guidelines","text":"","title":"Style Guidelines"},{"location":"about/#general","text":"Favor succinctness in writing Use max 3-4 sentences in a section (exceptions can be made when critical) Show, don\u2019t tell (examples speak more than lengthy exposition) Include a simple, illustrative example rather than complex examples that require substantial, extraneous reading Add a source link to the original document when available Create new sections when warranted Keep code lines under 80 characters when possible Mark code as insecure, bad, good where relevant Use the format of the Airbnb Javascript Style guide as a starting point","title":"General"},{"location":"about/#recommendations-section","text":"Always favor a declarative tip starting with a verb for the section title Include good and bad examples, when possible Ensure each subsection has an anchor tag for future hyperlinking","title":"Recommendations Section"},{"location":"about/#attacks-section","text":"Provide an example - then point to a recommendation for the solution in the relevant section of the doc List first/most visible attack, where possible Ensure each subsection has an anchor tag for future hyperlinking Mark vulnerable pieces of code as // INSECURE","title":"Attacks Section"},{"location":"about/license/","text":"Copyright 2016 Smart Contract Best Practices Authors Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"attacks/","text":"The following is a list of known attacks which you should be aware of, and defend against when writing smart contracts. Category Description Reentrancy Intra- and inter-function reentrancy attacks and potentially faulty solutions to them. Oracle Manipulation Manipulation of external data providers and potential solutions to oracle security issues. Frontrunning A definition and taxonomy around frontrunning and related attacks. Timestamp Dependence Attacks relating to the timing of a transaction. Insecure Arithmetic Integer overflows and underflows. Denial of Service Denial of service attacks through unexpected reverts and the block gas limit. Griefing Attacks relating to bad faith players around a smart contract system. Force Feeding Forcing Ether to be sent to smart contracts to manipulate balance checks. Deprecated/Historical Attacks that are part of Ethereum's history and vulnerabilities that have been fixes on a (Solidity) compiler level. More Where to find more information about vulnerabilities and weaknesses.","title":"Index"},{"location":"attacks/denial-of-service/","text":"DoS with (Unexpected) revert \u00b6 Consider a simple auction contract: // INSECURE contract Auction { address currentLeader ; uint highestBid ; function bid () payable { require ( msg.value > highestBid ); require ( currentLeader . send ( highestBid )); // Refund the old leader, if it fails then revert currentLeader = msg.sender ; highestBid = msg.value ; } } If attacker bids using a smart contract which has a fallback function that reverts any payment, the attacker can win any auction. When it tries to refund the old leader, it reverts if the refund fails. This means that a malicious bidder can become the leader while making sure that any refunds to their address will always fail. In this way, they can prevent anyone else from calling the bid() function, and stay the leader forever. A recommendation is to set up a pull payment system instead, as described earlier. Another example is when a contract may iterate through an array to pay users (e.g., supporters in a crowdfunding contract). It's common to want to make sure that each payment succeeds. If not, one should revert. The issue is that if one call fails, you are reverting the whole payout system, meaning the loop will never complete. No one gets paid because one address is forcing an error. address [] private refundAddresses ; mapping ( address => uint ) public refunds ; // bad function refundAll () public { for ( uint x ; x < refundAddresses . length ; x ++ ) { // arbitrary length iteration based on how many addresses participated require ( refundAddresses [ x ]. send ( refunds [ refundAddresses [ x ]])) // doubly bad, now a single failure on send will hold up all funds } } Again, the recommended solution is to favor pull over push payments . See SWC-113 DoS with Block Gas Limit \u00b6 Each block has an upper bound on the amount of gas that can be spent, and thus the amount computation that can be done. This is the Block Gas Limit. If the gas spent exceeds this limit, the transaction will fail. This leads to a couple of possible Denial of Service vectors: Gas Limit DoS on a Contract via Unbounded Operations \u00b6 You may have noticed another problem with the previous example: by paying out to everyone at once, you risk running into the block gas limit. This can lead to problems even in the absence of an intentional attack. However, it's especially bad if an attacker can manipulate the amount of gas needed. In the case of the previous example, the attacker could add a bunch of addresses, each of which needs to get a very small refund. The gas cost of refunding each of the attacker's addresses could, therefore, end up being more than the gas limit, blocking the refund transaction from happening at all. This is another reason to favor pull over push payments . If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. You will need to keep track of how far you've gone, and be able to resume from that point, as in the following example: struct Payee { address addr ; uint256 value ; } Payee [] payees ; uint256 nextPayeeIndex ; function payOut () { uint256 i = nextPayeeIndex ; while ( i < payees . length && msg.gas > 200000 ) { payees [ i ]. addr . send ( payees [ i ]. value ); i ++ ; } nextPayeeIndex = i ; } You will need to make sure that nothing bad will happen if other transactions are processed while waiting for the next iteration of the payOut() function. So only use this pattern if absolutely necessary. Gas Limit DoS on the Network via Block Stuffing \u00b6 Even if your contract does not contain an unbounded loop, an attacker can prevent other transactions from being included in the blockchain for several blocks by placing computationally intensive transactions with a high enough gas price. To do this, the attacker can issue several transactions which will consume the entire gas limit, with a high enough gas price to be included as soon as the next block is mined. No gas price can guarantee inclusion in the block, but the higher the price is, the higher is the chance. If the attack succeeds, no other transactions will be included in the block. Sometimes, an attacker's goal is to block transactions to a specific contract prior to specific time. This attack was conducted on Fomo3D, a gambling app. The app was designed to reward the last address that purchased a \"key\". Each key purchase extended the timer, and the game ended once the timer went to 0. The attacker bought a key and then stuffed 13 blocks in a row until the timer was triggered and the payout was released. Transactions sent by attacker took 7.9 million gas on each block, so the gas limit allowed a few small \"send\" transactions (which take 21,000 gas each), but disallowed any calls to the buyKey() function (which costs 300,000+ gas). A Block Stuffing attack can be used on any contract requiring an action within a certain time period. However, as with any attack, it is only profitable when the expected reward exceeds its cost. The cost of this attack is directly proportional to the number of blocks which need to be stuffed. If a large payout can be obtained by preventing actions from other participants, your contract will likely be targeted by such an attack. See SWC-128","title":"Denial of Service"},{"location":"attacks/denial-of-service/#dos-with-unexpected-revert","text":"Consider a simple auction contract: // INSECURE contract Auction { address currentLeader ; uint highestBid ; function bid () payable { require ( msg.value > highestBid ); require ( currentLeader . send ( highestBid )); // Refund the old leader, if it fails then revert currentLeader = msg.sender ; highestBid = msg.value ; } } If attacker bids using a smart contract which has a fallback function that reverts any payment, the attacker can win any auction. When it tries to refund the old leader, it reverts if the refund fails. This means that a malicious bidder can become the leader while making sure that any refunds to their address will always fail. In this way, they can prevent anyone else from calling the bid() function, and stay the leader forever. A recommendation is to set up a pull payment system instead, as described earlier. Another example is when a contract may iterate through an array to pay users (e.g., supporters in a crowdfunding contract). It's common to want to make sure that each payment succeeds. If not, one should revert. The issue is that if one call fails, you are reverting the whole payout system, meaning the loop will never complete. No one gets paid because one address is forcing an error. address [] private refundAddresses ; mapping ( address => uint ) public refunds ; // bad function refundAll () public { for ( uint x ; x < refundAddresses . length ; x ++ ) { // arbitrary length iteration based on how many addresses participated require ( refundAddresses [ x ]. send ( refunds [ refundAddresses [ x ]])) // doubly bad, now a single failure on send will hold up all funds } } Again, the recommended solution is to favor pull over push payments . See SWC-113","title":"DoS with (Unexpected) revert"},{"location":"attacks/denial-of-service/#dos-with-block-gas-limit","text":"Each block has an upper bound on the amount of gas that can be spent, and thus the amount computation that can be done. This is the Block Gas Limit. If the gas spent exceeds this limit, the transaction will fail. This leads to a couple of possible Denial of Service vectors:","title":"DoS with Block Gas Limit"},{"location":"attacks/denial-of-service/#gas-limit-dos-on-a-contract-via-unbounded-operations","text":"You may have noticed another problem with the previous example: by paying out to everyone at once, you risk running into the block gas limit. This can lead to problems even in the absence of an intentional attack. However, it's especially bad if an attacker can manipulate the amount of gas needed. In the case of the previous example, the attacker could add a bunch of addresses, each of which needs to get a very small refund. The gas cost of refunding each of the attacker's addresses could, therefore, end up being more than the gas limit, blocking the refund transaction from happening at all. This is another reason to favor pull over push payments . If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. You will need to keep track of how far you've gone, and be able to resume from that point, as in the following example: struct Payee { address addr ; uint256 value ; } Payee [] payees ; uint256 nextPayeeIndex ; function payOut () { uint256 i = nextPayeeIndex ; while ( i < payees . length && msg.gas > 200000 ) { payees [ i ]. addr . send ( payees [ i ]. value ); i ++ ; } nextPayeeIndex = i ; } You will need to make sure that nothing bad will happen if other transactions are processed while waiting for the next iteration of the payOut() function. So only use this pattern if absolutely necessary.","title":"Gas Limit DoS on a Contract via Unbounded Operations"},{"location":"attacks/denial-of-service/#gas-limit-dos-on-the-network-via-block-stuffing","text":"Even if your contract does not contain an unbounded loop, an attacker can prevent other transactions from being included in the blockchain for several blocks by placing computationally intensive transactions with a high enough gas price. To do this, the attacker can issue several transactions which will consume the entire gas limit, with a high enough gas price to be included as soon as the next block is mined. No gas price can guarantee inclusion in the block, but the higher the price is, the higher is the chance. If the attack succeeds, no other transactions will be included in the block. Sometimes, an attacker's goal is to block transactions to a specific contract prior to specific time. This attack was conducted on Fomo3D, a gambling app. The app was designed to reward the last address that purchased a \"key\". Each key purchase extended the timer, and the game ended once the timer went to 0. The attacker bought a key and then stuffed 13 blocks in a row until the timer was triggered and the payout was released. Transactions sent by attacker took 7.9 million gas on each block, so the gas limit allowed a few small \"send\" transactions (which take 21,000 gas each), but disallowed any calls to the buyKey() function (which costs 300,000+ gas). A Block Stuffing attack can be used on any contract requiring an action within a certain time period. However, as with any attack, it is only profitable when the expected reward exceeds its cost. The cost of this attack is directly proportional to the number of blocks which need to be stuffed. If a large payout can be obtained by preventing actions from other participants, your contract will likely be targeted by such an attack. See SWC-128","title":"Gas Limit DoS on the Network via Block Stuffing"},{"location":"attacks/deprecated/","text":"These are attacks which are no longer possible due to changes in the protocol or improvements to solidity. They are recorded here for posterity and awareness. Call Depth Attack (deprecated) \u00b6 As of the EIP 150 hardfork, call depth attacks are no longer relevant * (all gas would be consumed well before reaching the 1024 call depth limit). Constantinople Reentrancy Attack \u00b6 On January 16 th , 2019, Constantinople protocol upgrade was delayed due to a security vulnerability enabled by EIP 1283 . EIP 1283: Net gas metering for SSTORE without dirty maps proposes changes to reduce excessive gas costs on dirty storage writes. This change led to possibility of a new reentrancy vector making previously known secure withdrawal patterns ( .send() and .transfer() ) unsafe in specific situations * , where the attacker could hijack the control flow and use the remaining gas enabled by EIP 1283, leading to vulnerabilities due to reentrancy.","title":"Deprecated/Historical"},{"location":"attacks/deprecated/#call-depth-attack-deprecated","text":"As of the EIP 150 hardfork, call depth attacks are no longer relevant * (all gas would be consumed well before reaching the 1024 call depth limit).","title":"Call Depth Attack (deprecated)"},{"location":"attacks/deprecated/#constantinople-reentrancy-attack","text":"On January 16 th , 2019, Constantinople protocol upgrade was delayed due to a security vulnerability enabled by EIP 1283 . EIP 1283: Net gas metering for SSTORE without dirty maps proposes changes to reduce excessive gas costs on dirty storage writes. This change led to possibility of a new reentrancy vector making previously known secure withdrawal patterns ( .send() and .transfer() ) unsafe in specific situations * , where the attacker could hijack the control flow and use the remaining gas enabled by EIP 1283, leading to vulnerabilities due to reentrancy.","title":"Constantinople Reentrancy Attack"},{"location":"attacks/force-feeding/","text":"Forcing a smart contract to hold an Ether balance can influence its internal accounting and security assumptions. There are multiple ways a smart contract can receive Ether. The hierarchy is as follows: Check whether a payable external receive function is defined. If not, check whether a payable external fallback function is defined. Revert. The precedence of each function is explained in this great graphic from the Solidity by Example article: Which function is called, fallback() or receive()? send Ether | msg.data is empty? / \\ yes no / \\ receive() exists? fallback() / \\ yes no / \\ receive() fallback() Consider the following example: pragma solidity ^ 0.8 . 13 ; contract Vulnerable { receive () external payable { revert (); } function somethingBad () external { require ( address ( this ). balance > 0 ); // Do something bad } } The contract's logic seemingly disallows direct payments and prevents \"something bad\" from happening. However, calling revert in both fallback and receive cannot prevent the contract from receiving Ether . The following techniques can be used to force-feed Ether to a smart contract. Selfdestruct \u00b6 When the SELFDESTRUCT opcode is called, funds of the calling address are sent to the address on the stack, and execution is immediately halted. Since this opcode works on the EVM-level, Solidity-level functions that might block the receipt of Ether will not be executed . Pre-calculated Deployments \u00b6 Additionally, the target address of newly deployed smart contracts is generated in a deterministic fashion. The address generation can be looked up in any EVM implementation, such as the py-evm reference implementation by the Ethereum Foundation: def generate_contract_address ( address : Address , nonce : int ) -> Address : return force_bytes_to_address ( keccak ( rlp . encode ([ address , nonce ]))) An attacker can send funds to this address before the deployment has happened. This is also illustrated by this 2017 Underhanded Solidity Contest submission . Block Rewards and Coinbase \u00b6 Depending on the attacker's capabilities, they can also start proof-of-work mining. By setting the target address to their coinbase , block rewards will be added to its balance. As this is yet another EVM-level capability, checks performed by Solidity are ineffective. Solution \u00b6 The above effects illustrate that relying on exact comparisons to the contract's Ether balance is unreliable. The smart contract's business logic must consider that the actual balance associated with it can be higher than the internal accounting's value. In general, we strongly advise against using the contract's balance as a guard. More information can be found in SWC-132 .","title":"Force Feeding"},{"location":"attacks/force-feeding/#selfdestruct","text":"When the SELFDESTRUCT opcode is called, funds of the calling address are sent to the address on the stack, and execution is immediately halted. Since this opcode works on the EVM-level, Solidity-level functions that might block the receipt of Ether will not be executed .","title":"Selfdestruct"},{"location":"attacks/force-feeding/#pre-calculated-deployments","text":"Additionally, the target address of newly deployed smart contracts is generated in a deterministic fashion. The address generation can be looked up in any EVM implementation, such as the py-evm reference implementation by the Ethereum Foundation: def generate_contract_address ( address : Address , nonce : int ) -> Address : return force_bytes_to_address ( keccak ( rlp . encode ([ address , nonce ]))) An attacker can send funds to this address before the deployment has happened. This is also illustrated by this 2017 Underhanded Solidity Contest submission .","title":"Pre-calculated Deployments"},{"location":"attacks/force-feeding/#block-rewards-and-coinbase","text":"Depending on the attacker's capabilities, they can also start proof-of-work mining. By setting the target address to their coinbase , block rewards will be added to its balance. As this is yet another EVM-level capability, checks performed by Solidity are ineffective.","title":"Block Rewards and Coinbase"},{"location":"attacks/force-feeding/#solution","text":"The above effects illustrate that relying on exact comparisons to the contract's Ether balance is unreliable. The smart contract's business logic must consider that the actual balance associated with it can be higher than the internal accounting's value. In general, we strongly advise against using the contract's balance as a guard. More information can be found in SWC-132 .","title":"Solution"},{"location":"attacks/frontrunning/","text":"Since all transactions are visible in the mempool for a short while before being executed, observers of the network can see and react to an action before it is included in a block. An example of how this can be exploited is with a decentralized exchange where a buy order transaction can be seen, and second order can be broadcast and executed before the first transaction is included. Protecting against this is difficult, as it would come down to the specific contract itself. Front-running, coined originally for traditional financial markets, is the race to order the chaos to the winner's benefit. In financial markets, the flow of information gave birth to intermediaries that could simply profit by being the first to know and react to some information. These attacks mostly had been within stock market deals and early domain registries, such as whois gateways. front-run\u00b7ning (/\u02ccfr\u0259nt\u02c8r\u0259niNG/) noun : front-running; STOCK MARKET the practice by market makers of dealing on advance information provided by their brokers and investment analysts, before their clients have been given the information. Taxonomy \u00b6 By defining a taxonomy and differentiating each group from another, we can make it easier to discuss the problem and find solutions for each group. We define the following categories of front-running attacks: Displacement Insertion Suppression Displacement \u00b6 In the first type of attack, a displacement attack , it is not important for Alice\u2019s (User) function call to run after Mallory (Adversary) runs her function. Alice\u2019s can be orphaned or run with no meaningful effect. Examples of displacement include: Alice trying to register a domain name and Mallory registering it first; Alice trying to submit a bug to receive a bounty and Mallory stealing it and submitting it first; Alice trying to submit a bid in an auction and Mallory copying it. This attack is commonly performed by increasing the gasPrice higher than network average, often by a multiplier of 10 or more. Insertion \u00b6 For this type of attack, it is important to the adversary that the original function call runs after her transaction. In an insertion attack, after Mallory runs her function, the state of the contract is changed and she needs Alice\u2019s original function to run on this modified state. For example, if Alice places a purchase order on a blockchain asset at a higher price than the best offer, Mallory will insert two transactions: she will purchase at the best offer price and then offer the same asset for sale at Alice\u2019s slightly higher purchase price. If Alice\u2019s transaction is then run after, Mallory will profit on the price difference without having to hold the asset. As with displacement attacks, this is usually done by outbidding Alice's transaction in the gas price auction. Transaction Order Dependence Transaction Order Dependence is equivalent to race condition in smart contracts. An example, if one function sets the reward percentage, and the withdraw function uses that percentage; then withdraw transaction can be front-run by a change reward function call, which impacts the amount that will be withdrawn eventually. See SWC-114 Suppression \u00b6 In a suppression attack, a.k.a Block Stuffing attacks, after Mallory runs her function, she tries to delay Alice from running her function. This was the case with the first winner of the \"Fomo3d\" game and some other on-chain hacks. The attacker sent multiple transactions with a high gasPrice and gasLimit to custom smart contracts that assert (or use other means) to consume all the gas and fill up the block's gasLimit . Variants Each of these attacks has two variants, asymmetric and bulk . In some cases, Alice and Mallory are performing different operations. For example, Alice is trying to cancel an offer, and Mallory is trying to fulfill it first. We call this asymmetric displacement . In other cases, Mallory is trying to run a large set of functions: for example, Alice and others are trying to buy a limited set of shares offered by a firm on a blockchain. We call this bulk displacement . Mitigations \u00b6 Front-running is a pervasive issue on public blockchains such as Ethereum. The best remediation is to remove the benefit of front-running in your application , mainly by removing the importance of transaction ordering or time. For example, in markets, it would be better to implement batch auctions (this also protects against high-frequency trading concerns). Another way is to use a pre-commit scheme (\u201cI\u2019m going to submit the details later\u201d). A third option is to mitigate the cost of front-running by specifying a maximum or minimum acceptable price range on a trade, thereby limiting price slippage. Transaction Ordering: Go-Ethereum (Geth) nodes, order the transactions based on their gasPrice and address nonce. This, however, results in a gas auction between participants in the network to get included in the block currently being mined. Confidentiality: Another approach is to limit the visibility of the transactions, this can be done using a \"commit and reveal\" scheme. A simple implementation is to store the keccak256 hash of the data in the first transaction, then reveal the data and verify it against the hash in the second transaction. However note that the transaction itself leaks the intention and possibly the value of the collateralization. There are enhanced commit and reveal schemes that are more secure, however require more transactions to function, e.g. submarine sends .","title":"Frontrunning"},{"location":"attacks/frontrunning/#taxonomy","text":"By defining a taxonomy and differentiating each group from another, we can make it easier to discuss the problem and find solutions for each group. We define the following categories of front-running attacks: Displacement Insertion Suppression","title":"Taxonomy"},{"location":"attacks/frontrunning/#displacement","text":"In the first type of attack, a displacement attack , it is not important for Alice\u2019s (User) function call to run after Mallory (Adversary) runs her function. Alice\u2019s can be orphaned or run with no meaningful effect. Examples of displacement include: Alice trying to register a domain name and Mallory registering it first; Alice trying to submit a bug to receive a bounty and Mallory stealing it and submitting it first; Alice trying to submit a bid in an auction and Mallory copying it. This attack is commonly performed by increasing the gasPrice higher than network average, often by a multiplier of 10 or more.","title":"Displacement"},{"location":"attacks/frontrunning/#insertion","text":"For this type of attack, it is important to the adversary that the original function call runs after her transaction. In an insertion attack, after Mallory runs her function, the state of the contract is changed and she needs Alice\u2019s original function to run on this modified state. For example, if Alice places a purchase order on a blockchain asset at a higher price than the best offer, Mallory will insert two transactions: she will purchase at the best offer price and then offer the same asset for sale at Alice\u2019s slightly higher purchase price. If Alice\u2019s transaction is then run after, Mallory will profit on the price difference without having to hold the asset. As with displacement attacks, this is usually done by outbidding Alice's transaction in the gas price auction. Transaction Order Dependence Transaction Order Dependence is equivalent to race condition in smart contracts. An example, if one function sets the reward percentage, and the withdraw function uses that percentage; then withdraw transaction can be front-run by a change reward function call, which impacts the amount that will be withdrawn eventually. See SWC-114","title":"Insertion"},{"location":"attacks/frontrunning/#suppression","text":"In a suppression attack, a.k.a Block Stuffing attacks, after Mallory runs her function, she tries to delay Alice from running her function. This was the case with the first winner of the \"Fomo3d\" game and some other on-chain hacks. The attacker sent multiple transactions with a high gasPrice and gasLimit to custom smart contracts that assert (or use other means) to consume all the gas and fill up the block's gasLimit . Variants Each of these attacks has two variants, asymmetric and bulk . In some cases, Alice and Mallory are performing different operations. For example, Alice is trying to cancel an offer, and Mallory is trying to fulfill it first. We call this asymmetric displacement . In other cases, Mallory is trying to run a large set of functions: for example, Alice and others are trying to buy a limited set of shares offered by a firm on a blockchain. We call this bulk displacement .","title":"Suppression"},{"location":"attacks/frontrunning/#mitigations","text":"Front-running is a pervasive issue on public blockchains such as Ethereum. The best remediation is to remove the benefit of front-running in your application , mainly by removing the importance of transaction ordering or time. For example, in markets, it would be better to implement batch auctions (this also protects against high-frequency trading concerns). Another way is to use a pre-commit scheme (\u201cI\u2019m going to submit the details later\u201d). A third option is to mitigate the cost of front-running by specifying a maximum or minimum acceptable price range on a trade, thereby limiting price slippage. Transaction Ordering: Go-Ethereum (Geth) nodes, order the transactions based on their gasPrice and address nonce. This, however, results in a gas auction between participants in the network to get included in the block currently being mined. Confidentiality: Another approach is to limit the visibility of the transactions, this can be done using a \"commit and reveal\" scheme. A simple implementation is to store the keccak256 hash of the data in the first transaction, then reveal the data and verify it against the hash in the second transaction. However note that the transaction itself leaks the intention and possibly the value of the collateralization. There are enhanced commit and reveal schemes that are more secure, however require more transactions to function, e.g. submarine sends .","title":"Mitigations"},{"location":"attacks/griefing/","text":"This attack may be possible on a contract which accepts generic data and uses it to make a call another contract (a 'sub-call') via the low level address.call() function, as is often the case with multisignature and transaction relayer contracts. If the call fails, the contract has two options: revert the whole transaction continue execution. Take the following example of a simplified Relayer contract which continues execution regardless of the outcome of the subcall: contract Relayer { mapping ( bytes => bool ) executed ; function relay ( bytes _data ) public { // replay protection; do not call the same transaction twice require ( executed [ _data ] == 0 , \"Duplicate call\" ); executed [ _data ] = true ; innerContract . call ( bytes4 ( keccak256 ( \"execute(bytes)\" )), _data ); } } This contract allows transaction relaying. Someone who wants to make a transaction but can't execute it by himself (e.g. due to the lack of ether to pay for gas) can sign data that he wants to pass and transfer the data with his signature over any medium. A third party \"forwarder\" can then submit this transaction to the network on behalf of the user. If given just the right amount of gas, the Relayer would complete execution recording the _data argument in the executed mapping, but the subcall would fail because it received insufficient gas to complete execution. Note When a contract makes a sub-call to another contract, the EVM limits the gas forwarded to to 63/64 of the remaining gas , An attacker can use this to censor transactions, causing them to fail by sending them with a low amount of gas. This attack is a form of \" griefing \": It doesn't directly benefit the attacker, but causes grief for the victim. A dedicated attacker, willing to consistently spend a small amount of gas could theoretically censor all transactions this way, if they were the first to submit them to Relayer . One way to address this is to implement logic requiring forwarders to provide enough gas to finish the subcall. If the miner tried to conduct the attack in this scenario, the require statement would fail and the inner call would revert. A user can specify a minimum gasLimit along with the other data (in this example, typically the _gasLimit value would be verified by a signature, but that is omitted for simplicity in this case). // contract called by Relayer contract Executor { function execute ( bytes _data , uint _gasLimit ) { require ( gasleft () >= _gasLimit ); ... } } Another solution is to permit only trusted accounts to relay the transaction.","title":"Griefing"},{"location":"attacks/insecure-arithmetic/","text":"Consider a simple token transfer: mapping ( address => uint256 ) public balanceOf ; // INSECURE function transfer ( address _to , uint256 _value ) { /* Check if sender has balance */ require ( balanceOf [ msg.sender ] >= _value ); /* Add and subtract new balances */ balanceOf [ msg.sender ] -= _value ; balanceOf [ _to ] += _value ; } // SECURE function transfer ( address _to , uint256 _value ) { /* Check if sender has balance and for overflows */ require ( balanceOf [ msg.sender ] >= _value && balanceOf [ _to ] + _value >= balanceOf [ _to ]); /* Add and subtract new balances */ balanceOf [ msg.sender ] -= _value ; balanceOf [ _to ] += _value ; } If a balance reaches the maximum uint value (2^256) it will circle back to zero which checks for the condition. This may or may not be relevant, depending on the implementation. Think about whether or not the uint value has an opportunity to approach such a large number. Think about how the uint variable changes state, and who has authority to make such changes. If any user can call functions which update the uint value, it's more vulnerable to attack. If only an admin has access to change the variable's state, you might be safe. If a user can increment by only 1 at a time, you are probably also safe because there is no feasible way to reach this limit. The same is true for underflow. If a uint is made to be less than zero, it will cause an underflow and get set to its maximum value. Be careful with the smaller data-types like uint8, uint16, uint24...etc: they can even more easily hit their maximum value. Warning Be aware there are around 20 cases for overflow and underflow . One simple solution to mitigate the common mistakes for overflow and underflow is to use SafeMath.sol library for arithmetic functions. Solidity automatically reverts on integer overflow and underflow, as of version 0.8.0. See SWC-101","title":"Insecure Arithmetic"},{"location":"attacks/more/","text":"The Smart Contract Weakness Classification Registry offers a complete and up-to-date catalogue of known smart contract vulnerabilities and anti-patterns along with real-world examples. Browsing the registry is a good way of keeping up-to-date with the latest attacks. It has been proposed formally in EIP-1470 and is loosely aligned with the Common Weakness Enumeration ( CWE ). Additionally, the Smart Contract Security Verification Standard (SCSVS) contains a checklist-style collection of vital security properties aimed at standardizing the security of smart contracts for developers, architects, security reviewers and vendors.","title":"More"},{"location":"attacks/oracle-manipulation/","text":"Protocols sometimes require additional information from outside the realm of the blockchain to function correctly. Such off-chain information is provided by oracles , which often are smart contracts themselves. A vulnerability arises when protocols relying on oracles automatically execute actions even though the oracle-provided data feed is incorrect. An oracle with deprecated or even malicious contents can have disastrous effects on all processes connected to the data feed. In practice, manipulated data feeds can cause significant damage, from unwarranted liquidations to malicious arbitrage trades. The following sections provide examples illustrating common vulnerabilities and malfunctions involving oracles. Spot Price Manipulation \u00b6 A classic vulnerability comes from the world of on-chain price oracles: Trusting the spot price of a decentralized exchange. The scenario is simple. A smart contract needs to determine the price of an asset, e.g., when a user deposits ETH into its system. To achieve this price discovery, the protocol consults its respective Uniswap pool as a source. Exploiting this behavior, an attacker can take out a flash loan to drain one side of the Uniswap pool. Due to the lack of data source diversity, the protocol's internal price is directly manipulated, e.g., to 100 times the original value. The attacker can now perform an action to capture this additional value. For example, an arbitrage trade on top of the newly created price difference or an advantageous position in the system can be gained. The problems are two-fold: The use of a single price feed source smart contract allows for easy on-chain manipulation using flash loans. Despite a notable anomaly, the smart contracts consuming the price information continue to operate on the manipulated data. A more concrete example is provided by the Visor Hack. The following code shows that on deposit, the price feed is fetched directly from Uniswap: uint160 sqrtPrice = TickMath . getSqrtRatioAtTick ( currentTick ()); uint256 price = FullMath . mulDiv ( uint256 ( sqrtPrice ). mul ( uint256 ( sqrtPrice )), PRECISION , 2 ** ( 96 * 2 )); Here, currentTick() directly fetches the current price tick from a Uniswap pool: // @return tick Uniswap pool's current price tick function currentTick () public view returns ( int24 tick ) { (, tick , , , , , ) = pool . slot0 (); } As this price data is fetched from an on-chain dependency, and the price data is determined in the current transaction context, this spot price can be manipulated in the same transaction. An attacker can take out a flash loan on the incoming asset A and on the relevant Uniswap pool, swap asset A for asset B with a large volume. This trade will increase the price of asset B (increased demand) and reduce the cost of asset A (increased supply). When asset B is deposited into the above function, its price is still pumped up by the flash loan. Consequentially, asset B gives the attacker an over-proportional amount of shares. These shares can be withdrawn, giving the attacker equal parts of asset A and asset B from the pool. Repeating this process will drain the vulnerable pool of all funds. With the money gained from the withdrawal of their shares, the attacker can repay the flash loan. Warning Under no circumstances should a decentralized exchange's spot price be used directly for price discovery. Secure price calculation can be performed, e.g., by using time-weighted average prices (TWAPs) across longer time intervals. Assuming sufficient liquidity, this severely increases the cost of a price manipulation attack, making it unfeasible. An example for facilitating secure price discovery is the Uniswap V3 OracleLibrary docs. Off-Chain Infrastructure \u00b6 By definition, a data feed transporting off-chain information into a smart contract requires traditional software to run. From the sensor hardware or manual entry to authenticated APIs submitting data on-chain, it is not uncommon for a plethora of software to be involved. Depending on the concrete implementation, attacks on access control, cryptographic implementation, transport, and database security, among others, can be performed. As a result, software providing oracle services must be hardened and adhere to security best practices such as the OWASP Secure Coding Practices . Especially oracles which don't offer a community-driven dispute phase must be hardened as their compromise will directly affect dependent applications. Info Eskandari et al. divided the concept of an oracle into the following six modules: Ground Truth Data Sources Data Feeders Selection of Data Feeders Aggregation Dispute Phase Their publication provides a great read on design principles, attacks, and mitigations. Shayan Eskandari, Mehdi Salehi, Wanyun Catherine Gu, and Jeremy Clark. 2021. SoK: oracles from the ground truth to market manipulation. Proceedings of the 3rd ACM Conference on Advances in Financial Technologies. Association for Computing Machinery, New York, NY, USA, 127\u2013141. DOI:https://doi.org/10.1145/3479722.3480994 An excellent example of an off-chain component malfunction affecting on-chain oracle data feeds is the Synthetix sKRW incident. Synthetix aggregates multiple related price-feeds to accurately price their derivatives and surfaces the aggregate through a smart contract on-chain. With a value erroneously reported 1000 times higher than the original, the price of the Korean Won was reported significantly higher, even though the aggregation. An arbitrage bot used this effect, which promptly earned it a profit of over 1B USD. While on-chain aggregation and price reporting worked correctly, an off-chain component failure resulted in the incident. Info samczsun wrote a great article on the Paradigm blog elaborating this incident and various other price oracle related incidents. Centralized Oracles and Trust \u00b6 Projects can also choose to implement a centralized oracle. Such a smart contract's update method can, e.g., be protected by an onlyOwner modifier and require users to trust in the correct and timely submission of data. Depending on the size and structure of the system, this centralized trust can lead to the authorized user(s) getting incentivized to submit malicious data and abuse their position of power. Additionally, such centralized systems can have an inherent risk due to compromised private keys. Decentralized Oracle Security \u00b6 Decentralized oracles aim to diversify the group of data collectors to a point where disrupting a quorum of participants becomes unfeasible for an attacker. In a decentralized scenario, further security considerations stem from how participants are incentivized and what sort of misbehavior if left unpunished. Participants providing (valid) data to the oracle system are economically rewarded. Aiming to maximize their profit, the participants are incentivized to provide the cheapest version of their service possible. Freeloading \u00b6 Freeloading attacks are the simplest form to save work and maximize profit. A node can leverage another oracle or off-chain component (such as an API) and simply copy the values without validation. For example, an oracle providing weather data might expect data providers to measure temperature and wind speed in a specific location. Nodes are, however, incentivized to use a publicly available weather data API and simply surface their data to the system. Besides the apparent data source centralization issue, freeloading attacks at scale can also severely affect the data's correctness. This effect is most visible when sampling rates vary, e.g., the on-chain oracle expects a sampling rate of 10 minutes while freeloading nodes provide data from an API that is updated once every hour. Freeloading in decentralized oracle data marketplaces can amplify a price race to the bottom as freeloading only requires a simple lookup. At the same time, proper data provisioning might involve a more significant computational overhead. With less competition in cheaper price ranges, a few freeloading nodes could even be able to take over a data feed. Freeloading attacks can be easily prevented for more complex data feeds by implementing a commit-reveal scheme. This security measure will prevent oracle system participants from peeking into each other's data. For simpler data provisioning, consistency checks punishing nodes that obviously copy data from well-known public services can be implemented. Data collectors contributing to the centralization of the overall service will be disincentivized. Mirroring \u00b6 Mirroring attacks are a flavor of Sybil attacks and can go hand-in-hand with freeloading. Similarly, misbehaving nodes aim to save work by reading from a centralized data source, optionally with a reduced sampling rate. A single node reading from the centralized data source then replicates its values across other participants who mirror that data. With a single data read, the reward for providing the information is multiplied by the number of participants. As the number of mirroring participants grows, this increased weight on a single data point can significantly deteriorate error correction mechanisms. A similar outcome to a mirroring attack can happen accidentally when a large, uninformed part of a community relies on a single data source. A commit-reveal scheme is ineffective to mitigate (purposeful) mirroring attacks as it does not consider private data transfers between Sybil nodes. Due to the lack of transparency in Sybil communications, mirroring attacks can be very hard to detect in practice. Solutions \u00b6 Currently, the easiest ways to solve the oracle problem are decentralized oracles, such as: Chainlink is the largest decentralized oracle provider, and the Chainlink network can be leveraged to bring decentralized data on-chain. Tellor is an oracle that provides censorship-resistant data, secured by economic incentives, ensuring data can be provided by anyone, anytime, and checked by everyone. Witnet leverages state-of-the-art cryptographic and economic incentives to provide smart contracts with off-chain data. Using a median of multiple oracles provides heightened security since it is harder and more expensive to attack various oracles. It also ensures that a smart contract gets the data it needs even if one oracle or API call fails. Another standard solution is to use a time-weighted average price feed so that price is averaged out over X periods and multiple sources. Not only does this prevent oracle manipulation, but it also reduces the chance you can be front-run, as an order executed right before cannot have as drastic of an impact on the price. This condition does not apply for low liquidity assets, which are generally cheaper to manipulate, even for a prolonged time. Uniswap v2 provides a sliding window example .","title":"Oracle Manipulation"},{"location":"attacks/oracle-manipulation/#spot-price-manipulation","text":"A classic vulnerability comes from the world of on-chain price oracles: Trusting the spot price of a decentralized exchange. The scenario is simple. A smart contract needs to determine the price of an asset, e.g., when a user deposits ETH into its system. To achieve this price discovery, the protocol consults its respective Uniswap pool as a source. Exploiting this behavior, an attacker can take out a flash loan to drain one side of the Uniswap pool. Due to the lack of data source diversity, the protocol's internal price is directly manipulated, e.g., to 100 times the original value. The attacker can now perform an action to capture this additional value. For example, an arbitrage trade on top of the newly created price difference or an advantageous position in the system can be gained. The problems are two-fold: The use of a single price feed source smart contract allows for easy on-chain manipulation using flash loans. Despite a notable anomaly, the smart contracts consuming the price information continue to operate on the manipulated data. A more concrete example is provided by the Visor Hack. The following code shows that on deposit, the price feed is fetched directly from Uniswap: uint160 sqrtPrice = TickMath . getSqrtRatioAtTick ( currentTick ()); uint256 price = FullMath . mulDiv ( uint256 ( sqrtPrice ). mul ( uint256 ( sqrtPrice )), PRECISION , 2 ** ( 96 * 2 )); Here, currentTick() directly fetches the current price tick from a Uniswap pool: // @return tick Uniswap pool's current price tick function currentTick () public view returns ( int24 tick ) { (, tick , , , , , ) = pool . slot0 (); } As this price data is fetched from an on-chain dependency, and the price data is determined in the current transaction context, this spot price can be manipulated in the same transaction. An attacker can take out a flash loan on the incoming asset A and on the relevant Uniswap pool, swap asset A for asset B with a large volume. This trade will increase the price of asset B (increased demand) and reduce the cost of asset A (increased supply). When asset B is deposited into the above function, its price is still pumped up by the flash loan. Consequentially, asset B gives the attacker an over-proportional amount of shares. These shares can be withdrawn, giving the attacker equal parts of asset A and asset B from the pool. Repeating this process will drain the vulnerable pool of all funds. With the money gained from the withdrawal of their shares, the attacker can repay the flash loan. Warning Under no circumstances should a decentralized exchange's spot price be used directly for price discovery. Secure price calculation can be performed, e.g., by using time-weighted average prices (TWAPs) across longer time intervals. Assuming sufficient liquidity, this severely increases the cost of a price manipulation attack, making it unfeasible. An example for facilitating secure price discovery is the Uniswap V3 OracleLibrary docs.","title":"Spot Price Manipulation"},{"location":"attacks/oracle-manipulation/#off-chain-infrastructure","text":"By definition, a data feed transporting off-chain information into a smart contract requires traditional software to run. From the sensor hardware or manual entry to authenticated APIs submitting data on-chain, it is not uncommon for a plethora of software to be involved. Depending on the concrete implementation, attacks on access control, cryptographic implementation, transport, and database security, among others, can be performed. As a result, software providing oracle services must be hardened and adhere to security best practices such as the OWASP Secure Coding Practices . Especially oracles which don't offer a community-driven dispute phase must be hardened as their compromise will directly affect dependent applications. Info Eskandari et al. divided the concept of an oracle into the following six modules: Ground Truth Data Sources Data Feeders Selection of Data Feeders Aggregation Dispute Phase Their publication provides a great read on design principles, attacks, and mitigations. Shayan Eskandari, Mehdi Salehi, Wanyun Catherine Gu, and Jeremy Clark. 2021. SoK: oracles from the ground truth to market manipulation. Proceedings of the 3rd ACM Conference on Advances in Financial Technologies. Association for Computing Machinery, New York, NY, USA, 127\u2013141. DOI:https://doi.org/10.1145/3479722.3480994 An excellent example of an off-chain component malfunction affecting on-chain oracle data feeds is the Synthetix sKRW incident. Synthetix aggregates multiple related price-feeds to accurately price their derivatives and surfaces the aggregate through a smart contract on-chain. With a value erroneously reported 1000 times higher than the original, the price of the Korean Won was reported significantly higher, even though the aggregation. An arbitrage bot used this effect, which promptly earned it a profit of over 1B USD. While on-chain aggregation and price reporting worked correctly, an off-chain component failure resulted in the incident. Info samczsun wrote a great article on the Paradigm blog elaborating this incident and various other price oracle related incidents.","title":"Off-Chain Infrastructure"},{"location":"attacks/oracle-manipulation/#centralized-oracles-and-trust","text":"Projects can also choose to implement a centralized oracle. Such a smart contract's update method can, e.g., be protected by an onlyOwner modifier and require users to trust in the correct and timely submission of data. Depending on the size and structure of the system, this centralized trust can lead to the authorized user(s) getting incentivized to submit malicious data and abuse their position of power. Additionally, such centralized systems can have an inherent risk due to compromised private keys.","title":"Centralized Oracles and Trust"},{"location":"attacks/oracle-manipulation/#decentralized-oracle-security","text":"Decentralized oracles aim to diversify the group of data collectors to a point where disrupting a quorum of participants becomes unfeasible for an attacker. In a decentralized scenario, further security considerations stem from how participants are incentivized and what sort of misbehavior if left unpunished. Participants providing (valid) data to the oracle system are economically rewarded. Aiming to maximize their profit, the participants are incentivized to provide the cheapest version of their service possible.","title":"Decentralized Oracle Security"},{"location":"attacks/oracle-manipulation/#freeloading","text":"Freeloading attacks are the simplest form to save work and maximize profit. A node can leverage another oracle or off-chain component (such as an API) and simply copy the values without validation. For example, an oracle providing weather data might expect data providers to measure temperature and wind speed in a specific location. Nodes are, however, incentivized to use a publicly available weather data API and simply surface their data to the system. Besides the apparent data source centralization issue, freeloading attacks at scale can also severely affect the data's correctness. This effect is most visible when sampling rates vary, e.g., the on-chain oracle expects a sampling rate of 10 minutes while freeloading nodes provide data from an API that is updated once every hour. Freeloading in decentralized oracle data marketplaces can amplify a price race to the bottom as freeloading only requires a simple lookup. At the same time, proper data provisioning might involve a more significant computational overhead. With less competition in cheaper price ranges, a few freeloading nodes could even be able to take over a data feed. Freeloading attacks can be easily prevented for more complex data feeds by implementing a commit-reveal scheme. This security measure will prevent oracle system participants from peeking into each other's data. For simpler data provisioning, consistency checks punishing nodes that obviously copy data from well-known public services can be implemented. Data collectors contributing to the centralization of the overall service will be disincentivized.","title":"Freeloading"},{"location":"attacks/oracle-manipulation/#mirroring","text":"Mirroring attacks are a flavor of Sybil attacks and can go hand-in-hand with freeloading. Similarly, misbehaving nodes aim to save work by reading from a centralized data source, optionally with a reduced sampling rate. A single node reading from the centralized data source then replicates its values across other participants who mirror that data. With a single data read, the reward for providing the information is multiplied by the number of participants. As the number of mirroring participants grows, this increased weight on a single data point can significantly deteriorate error correction mechanisms. A similar outcome to a mirroring attack can happen accidentally when a large, uninformed part of a community relies on a single data source. A commit-reveal scheme is ineffective to mitigate (purposeful) mirroring attacks as it does not consider private data transfers between Sybil nodes. Due to the lack of transparency in Sybil communications, mirroring attacks can be very hard to detect in practice.","title":"Mirroring"},{"location":"attacks/oracle-manipulation/#solutions","text":"Currently, the easiest ways to solve the oracle problem are decentralized oracles, such as: Chainlink is the largest decentralized oracle provider, and the Chainlink network can be leveraged to bring decentralized data on-chain. Tellor is an oracle that provides censorship-resistant data, secured by economic incentives, ensuring data can be provided by anyone, anytime, and checked by everyone. Witnet leverages state-of-the-art cryptographic and economic incentives to provide smart contracts with off-chain data. Using a median of multiple oracles provides heightened security since it is harder and more expensive to attack various oracles. It also ensures that a smart contract gets the data it needs even if one oracle or API call fails. Another standard solution is to use a time-weighted average price feed so that price is averaged out over X periods and multiple sources. Not only does this prevent oracle manipulation, but it also reduces the chance you can be front-run, as an order executed right before cannot have as drastic of an impact on the price. This condition does not apply for low liquidity assets, which are generally cheaper to manipulate, even for a prolonged time. Uniswap v2 provides a sliding window example .","title":"Solutions"},{"location":"attacks/reentrancy/","text":"One of the major dangers of calling external contracts is that they can take over the control flow, and make changes to your data that the calling function wasn't expecting. This class of bugs can take many forms, and both of the major bugs that led to the DAO's collapse were bugs of this sort. Reentrancy on a Single Function \u00b6 The first version of this bug to be noticed involved functions that could be called repeatedly, before the first invocation of the function was finished. This may cause the different invocations of the function to interact in destructive ways. // INSECURE mapping ( address => uint ) private userBalances ; function withdrawBalance () public { uint amountToWithdraw = userBalances [ msg.sender ]; ( bool success , ) = msg.sender . call . value ( amountToWithdraw )( \"\" ); // At this point, the caller's code is executed, and can call withdrawBalance again require ( success ); userBalances [ msg.sender ] = 0 ; } Since the user's balance is not set to 0 until the very end of the function, the second (and later) invocations will still succeed and will withdraw the balance over and over again. Factoid A DAO is a Decentralized Autonomous Organization. Its goal is to codify the rules and decision-making apparatus of an organization, eliminating the need for documents and people in governing, creating a structure with decentralized control. On June 17th 2016, [The DAO](https://www.coindesk.com/understanding-dao-hack-journalists) was hacked and 3.6 million Ether ($50 Million) were stolen using the first reentrancy attack. Ethereum Foundation issued a critical update to rollback the hack. This resulted in Ethereum being forked into Ethereum Classic and Ethereum. In the example given, the best way to prevent this attack is to make sure you don't call an external function until you've done all the internal work you need to do: mapping ( address => uint ) private userBalances ; function withdrawBalance () public { uint amountToWithdraw = userBalances [ msg.sender ]; userBalances [ msg.sender ] = 0 ; ( bool success , ) = msg.sender . call . value ( amountToWithdraw )( \"\" ); // The user's balance is already 0, so future invocations won't withdraw anything require ( success ); } Note that if you had another function which called withdrawBalance() , it would be potentially subject to the same attack, so you must treat any function which calls an untrusted contract as itself untrusted. See below for further discussion of potential solutions. Cross-function Reentrancy \u00b6 An attacker may also be able to do a similar attack using two different functions that share the same state. // INSECURE mapping ( address => uint ) private userBalances ; function transfer ( address to , uint amount ) { if ( userBalances [ msg.sender ] >= amount ) { userBalances [ to ] += amount ; userBalances [ msg.sender ] -= amount ; } } function withdrawBalance () public { uint amountToWithdraw = userBalances [ msg.sender ]; ( bool success , ) = msg.sender . call . value ( amountToWithdraw )( \"\" ); // At this point, the caller's code is executed, and can call transfer() require ( success ); userBalances [ msg.sender ] = 0 ; } In this case, the attacker calls transfer() when their code is executed on the external call in withdrawBalance . Since their balance has not yet been set to 0, they are able to transfer the tokens even though they already received the withdrawal. This vulnerability was also used in the DAO attack. The same solutions will work, with the same caveats. Also note that in this example, both functions were part of the same contract. However, the same bug can occur across multiple contracts, if those contracts share state. Pitfalls in Reentrancy Solutions \u00b6 Since reentrancy can occur across multiple functions, and even multiple contracts, any solution aimed at preventing reentrancy with a single function will not be sufficient. Instead, we have recommended finishing all internal work (ie. state changes) first, and only then calling the external function . This rule, if followed carefully, will allow you to avoid vulnerabilities due to reentrancy. However, you need to not only avoid calling external functions too soon, but also avoid calling functions which call external functions. For example, the following is insecure: // INSECURE mapping ( address => uint ) private userBalances ; mapping ( address => bool ) private claimedBonus ; mapping ( address => uint ) private rewardsForA ; function withdrawReward ( address recipient ) public { uint amountToWithdraw = rewardsForA [ recipient ]; rewardsForA [ recipient ] = 0 ; ( bool success , ) = recipient . call . value ( amountToWithdraw )( \"\" ); require ( success ); } function getFirstWithdrawalBonus ( address recipient ) public { require ( ! claimedBonus [ recipient ]); // Each recipient should only be able to claim the bonus once rewardsForA [ recipient ] += 100 ; withdrawReward ( recipient ); // At this point, the caller will be able to execute getFirstWithdrawalBonus again. claimedBonus [ recipient ] = true ; } Even though getFirstWithdrawalBonus() doesn't directly call an external contract, the call in withdrawReward() is enough to make it vulnerable to a reentrancy. You therefore need to treat withdrawReward() as if it were also untrusted. mapping ( address => uint ) private userBalances ; mapping ( address => bool ) private claimedBonus ; mapping ( address => uint ) private rewardsForA ; function untrustedWithdrawReward ( address recipient ) public { uint amountToWithdraw = rewardsForA [ recipient ]; rewardsForA [ recipient ] = 0 ; ( bool success , ) = recipient . call . value ( amountToWithdraw )( \"\" ); require ( success ); } function untrustedGetFirstWithdrawalBonus ( address recipient ) public { require ( ! claimedBonus [ recipient ]); // Each recipient should only be able to claim the bonus once claimedBonus [ recipient ] = true ; rewardsForA [ recipient ] += 100 ; untrustedWithdrawReward ( recipient ); // claimedBonus has been set to true, so reentry is impossible } In addition to the fix making reentry impossible, untrusted functions have been marked . This same pattern repeats at every level: since untrustedGetFirstWithdrawalBonus() calls untrustedWithdrawReward() , which calls an external contract, you must also treat untrustedGetFirstWithdrawalBonus() as insecure. Another solution often suggested is a mutex . This allows you to \"lock\" some state so it can only be changed by the owner of the lock. A simple example might look like this: // Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state mapping ( address => uint ) private balances ; bool private lockBalances ; function deposit () payable public returns ( bool ) { require ( ! lockBalances ); lockBalances = true ; balances [ msg.sender ] += msg.value ; lockBalances = false ; return true ; } function withdraw ( uint amount ) payable public returns ( bool ) { require ( ! lockBalances && amount > 0 && balances [ msg.sender ] >= amount ); lockBalances = true ; ( bool success , ) = msg.sender . call . value ( amount )( \"\" ); if ( success ) { // Normally insecure, but the mutex saves it balances [ msg.sender ] -= amount ; } lockBalances = false ; return true ; } If the user tries to call withdraw() again before the first call finishes, the lock will prevent it from having any effect. This can be an effective pattern, but it gets tricky when you have multiple contracts that need to cooperate. The following is insecure: // INSECURE contract StateHolder { uint private n ; address private lockHolder ; function getLock () { require ( lockHolder == address ( 0 )); lockHolder = msg.sender ; } function releaseLock () { require ( msg.sender == lockHolder ); lockHolder = address ( 0 ); } function set ( uint newState ) { require ( msg.sender == lockHolder ); n = newState ; } } An attacker can call getLock() , and then never call releaseLock() . If they do this, then the contract will be locked forever, and no further changes will be able to be made. If you use mutexes to protect against reentrancy, you will need to carefully ensure that there are no ways for a lock to be claimed and never released. (There are other potential dangers when programming with mutexes, such as deadlocks and livelocks. You should consult the large amount of literature already written on mutexes, if you decide to go this route.) See SWC-107 Above were examples of reentrancy involving the attacker executing malicious code within a single transaction . The following are a different type of attack inherent to Blockchains: the fact that the order of transactions themselves (e.g. within a block) is easily subject to manipulation.","title":"Reentrancy"},{"location":"attacks/reentrancy/#reentrancy-on-a-single-function","text":"The first version of this bug to be noticed involved functions that could be called repeatedly, before the first invocation of the function was finished. This may cause the different invocations of the function to interact in destructive ways. // INSECURE mapping ( address => uint ) private userBalances ; function withdrawBalance () public { uint amountToWithdraw = userBalances [ msg.sender ]; ( bool success , ) = msg.sender . call . value ( amountToWithdraw )( \"\" ); // At this point, the caller's code is executed, and can call withdrawBalance again require ( success ); userBalances [ msg.sender ] = 0 ; } Since the user's balance is not set to 0 until the very end of the function, the second (and later) invocations will still succeed and will withdraw the balance over and over again. Factoid A DAO is a Decentralized Autonomous Organization. Its goal is to codify the rules and decision-making apparatus of an organization, eliminating the need for documents and people in governing, creating a structure with decentralized control. On June 17th 2016, [The DAO](https://www.coindesk.com/understanding-dao-hack-journalists) was hacked and 3.6 million Ether ($50 Million) were stolen using the first reentrancy attack. Ethereum Foundation issued a critical update to rollback the hack. This resulted in Ethereum being forked into Ethereum Classic and Ethereum. In the example given, the best way to prevent this attack is to make sure you don't call an external function until you've done all the internal work you need to do: mapping ( address => uint ) private userBalances ; function withdrawBalance () public { uint amountToWithdraw = userBalances [ msg.sender ]; userBalances [ msg.sender ] = 0 ; ( bool success , ) = msg.sender . call . value ( amountToWithdraw )( \"\" ); // The user's balance is already 0, so future invocations won't withdraw anything require ( success ); } Note that if you had another function which called withdrawBalance() , it would be potentially subject to the same attack, so you must treat any function which calls an untrusted contract as itself untrusted. See below for further discussion of potential solutions.","title":"Reentrancy on a Single Function"},{"location":"attacks/reentrancy/#cross-function-reentrancy","text":"An attacker may also be able to do a similar attack using two different functions that share the same state. // INSECURE mapping ( address => uint ) private userBalances ; function transfer ( address to , uint amount ) { if ( userBalances [ msg.sender ] >= amount ) { userBalances [ to ] += amount ; userBalances [ msg.sender ] -= amount ; } } function withdrawBalance () public { uint amountToWithdraw = userBalances [ msg.sender ]; ( bool success , ) = msg.sender . call . value ( amountToWithdraw )( \"\" ); // At this point, the caller's code is executed, and can call transfer() require ( success ); userBalances [ msg.sender ] = 0 ; } In this case, the attacker calls transfer() when their code is executed on the external call in withdrawBalance . Since their balance has not yet been set to 0, they are able to transfer the tokens even though they already received the withdrawal. This vulnerability was also used in the DAO attack. The same solutions will work, with the same caveats. Also note that in this example, both functions were part of the same contract. However, the same bug can occur across multiple contracts, if those contracts share state.","title":"Cross-function Reentrancy"},{"location":"attacks/reentrancy/#pitfalls-in-reentrancy-solutions","text":"Since reentrancy can occur across multiple functions, and even multiple contracts, any solution aimed at preventing reentrancy with a single function will not be sufficient. Instead, we have recommended finishing all internal work (ie. state changes) first, and only then calling the external function . This rule, if followed carefully, will allow you to avoid vulnerabilities due to reentrancy. However, you need to not only avoid calling external functions too soon, but also avoid calling functions which call external functions. For example, the following is insecure: // INSECURE mapping ( address => uint ) private userBalances ; mapping ( address => bool ) private claimedBonus ; mapping ( address => uint ) private rewardsForA ; function withdrawReward ( address recipient ) public { uint amountToWithdraw = rewardsForA [ recipient ]; rewardsForA [ recipient ] = 0 ; ( bool success , ) = recipient . call . value ( amountToWithdraw )( \"\" ); require ( success ); } function getFirstWithdrawalBonus ( address recipient ) public { require ( ! claimedBonus [ recipient ]); // Each recipient should only be able to claim the bonus once rewardsForA [ recipient ] += 100 ; withdrawReward ( recipient ); // At this point, the caller will be able to execute getFirstWithdrawalBonus again. claimedBonus [ recipient ] = true ; } Even though getFirstWithdrawalBonus() doesn't directly call an external contract, the call in withdrawReward() is enough to make it vulnerable to a reentrancy. You therefore need to treat withdrawReward() as if it were also untrusted. mapping ( address => uint ) private userBalances ; mapping ( address => bool ) private claimedBonus ; mapping ( address => uint ) private rewardsForA ; function untrustedWithdrawReward ( address recipient ) public { uint amountToWithdraw = rewardsForA [ recipient ]; rewardsForA [ recipient ] = 0 ; ( bool success , ) = recipient . call . value ( amountToWithdraw )( \"\" ); require ( success ); } function untrustedGetFirstWithdrawalBonus ( address recipient ) public { require ( ! claimedBonus [ recipient ]); // Each recipient should only be able to claim the bonus once claimedBonus [ recipient ] = true ; rewardsForA [ recipient ] += 100 ; untrustedWithdrawReward ( recipient ); // claimedBonus has been set to true, so reentry is impossible } In addition to the fix making reentry impossible, untrusted functions have been marked . This same pattern repeats at every level: since untrustedGetFirstWithdrawalBonus() calls untrustedWithdrawReward() , which calls an external contract, you must also treat untrustedGetFirstWithdrawalBonus() as insecure. Another solution often suggested is a mutex . This allows you to \"lock\" some state so it can only be changed by the owner of the lock. A simple example might look like this: // Note: This is a rudimentary example, and mutexes are particularly useful where there is substantial logic and/or shared state mapping ( address => uint ) private balances ; bool private lockBalances ; function deposit () payable public returns ( bool ) { require ( ! lockBalances ); lockBalances = true ; balances [ msg.sender ] += msg.value ; lockBalances = false ; return true ; } function withdraw ( uint amount ) payable public returns ( bool ) { require ( ! lockBalances && amount > 0 && balances [ msg.sender ] >= amount ); lockBalances = true ; ( bool success , ) = msg.sender . call . value ( amount )( \"\" ); if ( success ) { // Normally insecure, but the mutex saves it balances [ msg.sender ] -= amount ; } lockBalances = false ; return true ; } If the user tries to call withdraw() again before the first call finishes, the lock will prevent it from having any effect. This can be an effective pattern, but it gets tricky when you have multiple contracts that need to cooperate. The following is insecure: // INSECURE contract StateHolder { uint private n ; address private lockHolder ; function getLock () { require ( lockHolder == address ( 0 )); lockHolder = msg.sender ; } function releaseLock () { require ( msg.sender == lockHolder ); lockHolder = address ( 0 ); } function set ( uint newState ) { require ( msg.sender == lockHolder ); n = newState ; } } An attacker can call getLock() , and then never call releaseLock() . If they do this, then the contract will be locked forever, and no further changes will be able to be made. If you use mutexes to protect against reentrancy, you will need to carefully ensure that there are no ways for a lock to be claimed and never released. (There are other potential dangers when programming with mutexes, such as deadlocks and livelocks. You should consult the large amount of literature already written on mutexes, if you decide to go this route.) See SWC-107 Above were examples of reentrancy involving the attacker executing malicious code within a single transaction . The following are a different type of attack inherent to Blockchains: the fact that the order of transactions themselves (e.g. within a block) is easily subject to manipulation.","title":"Pitfalls in Reentrancy Solutions"},{"location":"attacks/timestamp-dependence/","text":"Be aware that the timestamp of the block can be manipulated by the miner, and all direct and indirect uses of the timestamp should be considered. Note See the Recommendations section for design considerations related to Timestamp Dependence. See SWC-116","title":"Timestamp Dependence"},{"location":"development-recommendations/","text":"The development recommendations are split into six categories. Category Description General Guiding principles that should be kept in mind during development. Precautions Principles that prevent attacks in general or avoid excessive damage in the worst case scenario. Solidity-specific Helpful tips when building smart contracts in Solidity - including interesting quirks. Token-specifc Recommendations to honour when dealing with or implementing tokens Documentation Guidelines on how to properly document smart contracts and the processes surrounding them. Deprecated Vulnerabilities that were applicable in the past but can be reasonably excluded nowadays.","title":"Index"},{"location":"development-recommendations/deprecated/constructor-naming/","text":"","title":"Constructor Naming"},{"location":"development-recommendations/deprecated/division-by-zero/","text":"Prior to version 0.4, Solidity returns zero and does not throw an exception when a number is divided by zero. Ensure you're running at least version 0.4.","title":"Division by Zero"},{"location":"development-recommendations/deprecated/functions-and-events/","text":"Differentiate functions and events (Solidity \\< 0.4.21) \u00b6 Favor capitalization and a prefix in front of events (we suggest Log ), to prevent the risk of confusion between functions and events. For functions, always start with a lowercase letter, except for the constructor. // bad event Transfer () {} function transfer () {} // good event LogTransfer () {} function transfer () external {} Note In v0.4.21 Solidity introduced the emit keyword to indicate an event emit EventName(); . As of 0.5.0, it is required.","title":"Functions and Events"},{"location":"development-recommendations/deprecated/functions-and-events/#differentiate-functions-and-events-solidity-0421","text":"Favor capitalization and a prefix in front of events (we suggest Log ), to prevent the risk of confusion between functions and events. For functions, always start with a lowercase letter, except for the constructor. // bad event Transfer () {} function transfer () {} // good event LogTransfer () {} function transfer () external {} Note In v0.4.21 Solidity introduced the emit keyword to indicate an event emit EventName(); . As of 0.5.0, it is required.","title":"Differentiate functions and events (Solidity \\&lt; 0.4.21)"},{"location":"development-recommendations/documentation/contact/","text":"Who to contact with issues Names of programmers and/or other important parties Chat room where questions can be asked","title":"Contact"},{"location":"development-recommendations/documentation/general/","text":"When launching a contract that will have substantial funds or is required to be mission critical, it is important to include proper documentation.","title":"General"},{"location":"development-recommendations/documentation/history/","text":"Testing (including usage stats, discovered bugs, length of testing) People who have reviewed code (and their key feedback)","title":"History"},{"location":"development-recommendations/documentation/known-issues/","text":"Key risks with contract e.g., You can lose all your money, hacker can vote for certain outcomes All known bugs/limitations Potential attacks and mitigants Potential conflicts of interest (e.g., will be using yourself, like Slock.it did with the DAO)","title":"Known Issues"},{"location":"development-recommendations/documentation/procedures/","text":"Action plan in case a bug is discovered (e.g., emergency options, public notification process, etc.) Wind down process if something goes wrong (e.g., funders will get percentage of your balance before attack, from remaining funds) Responsible disclosure policy (e.g., where to report bugs found, the rules of any bug bounty program) Recourse in case of failure (e.g., insurance, penalty fund, no recourse)","title":"Procedures"},{"location":"development-recommendations/documentation/specification/","text":"Specs, diagrams, state machines, models, and other documentation that helps auditors, reviewers, and the community understand what the system is intended to do. Many bugs can be found just from the specifications, and they are the least costly to fix. Rollout plans that include details listed here , and target dates.","title":"Specification"},{"location":"development-recommendations/documentation/status/","text":"Where current code is deployed Compiler version, flags used, and steps for verifying the deployed bytecode matches the source code Compiler versions and flags that will be used for the different phases of rollout. Current status of deployed code (including outstanding issues, performance stats, etc.)","title":"Status"},{"location":"development-recommendations/general/external-calls/","text":"Use caution when making external calls \u00b6 Calls to untrusted contracts can introduce several unexpected risks or errors. External calls may execute malicious code in that contract or any other contract that it depends upon. As such, every external call should be treated as a potential security risk. When it is not possible, or undesirable to remove external calls, use the recommendations in the rest of this section to minimize the danger. Mark untrusted contracts \u00b6 When interacting with external contracts, name your variables, methods, and contract interfaces in a way that makes it clear that interacting with them is potentially unsafe. This applies to your own functions that call external contracts. // bad Bank . withdraw ( 100 ); // Unclear whether trusted or untrusted function makeWithdrawal ( uint amount ) { // Isn't clear that this function is potentially unsafe Bank . withdraw ( amount ); } // good UntrustedBank . withdraw ( 100 ); // untrusted external call TrustedBank . withdraw ( 100 ); // external but trusted bank contract maintained by XYZ Corp function makeUntrustedWithdrawal ( uint amount ) { UntrustedBank . withdraw ( amount ); } Avoid state changes after external calls \u00b6 Whether using raw calls (of the form someAddress.call() ) or contract calls (of the form ExternalContract.someMethod() ), assume that malicious code might execute. Even if ExternalContract is not malicious, malicious code can be executed by any contracts it calls. One particular danger is malicious code may hijack the control flow, leading to vulnerabilities due to reentrancy. (See Reentrancy for a fuller discussion of this problem). If you are making a call to an untrusted external contract, avoid state changes after the call . This pattern is also sometimes known as the checks-effects-interactions pattern . See SWC-107 Don't use transfer() or send() . \u00b6 .transfer() and .send() forward exactly 2,300 gas to the recipient. The goal of this hardcoded gas stipend was to prevent reentrancy vulnerabilities , but this only makes sense under the assumption that gas costs are constant. Recently EIP 1884 was included in the Istanbul hard fork. One of the changes included in EIP 1884 is an increase to the gas cost of the SLOAD operation, causing a contract's fallback function to cost more than 2300 gas. It's recommended to stop using .transfer() and .send() and instead use .call() . // bad contract Vulnerable { function withdraw(uint256 amount) external { // This forwards 2300 gas, which may not be enough if the recipient // is a contract and gas costs change. msg.sender.transfer(amount); } } // good contract Fixed { function withdraw(uint256 amount) external { // This forwards all available gas. Be sure to check the return value! (bool success, ) = msg.sender.call.value(amount)(\"\"); require(success, \"Transfer failed.\"); } } Note that .call() does nothing to mitigate reentrancy attacks, so other precautions must be taken. To prevent reentrancy attacks, it is recommended that you use the checks-effects-interactions pattern . Handle errors in external calls \u00b6 Solidity offers low-level call methods that work on raw addresses: address.call() , address.callcode() , address.delegatecall() , and address.send() . These low-level methods never throw an exception, but will return false if the call encounters an exception. On the other hand, contract calls (e.g., ExternalContract.doSomething() ) will automatically propagate a throw (for example, ExternalContract.doSomething() will also throw if doSomething() throws). If you choose to use the low-level call methods, make sure to handle the possibility that the call will fail, by checking the return value. // bad someAddress . send ( 55 ); someAddress . call . value ( 55 )( \"\" ); // this is doubly dangerous, as it will forward all remaining gas and doesn't check for result someAddress . call . value ( 100 )( bytes4 ( sha3 ( \"deposit()\" ))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted // good ( bool success , ) = someAddress . call . value ( 55 )( \"\" ); if ( ! success ) { // handle failure code } ExternalContract ( someAddress ). deposit . value ( 100 )(); See SWC-104 Favor pull over push for external calls \u00b6 External calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is often better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically. (This also reduces the chance of problems with the gas limit .) Avoid combining multiple ether transfers in a single transaction. // bad contract auction { address highestBidder ; uint highestBid ; function bid () payable { require ( msg.value >= highestBid ); if ( highestBidder != address ( 0 )) { ( bool success , ) = highestBidder . call . value ( highestBid )( \"\" ); require ( success ); // if this call consistently fails, no one else can bid } highestBidder = msg.sender ; highestBid = msg.value ; } } // good contract auction { address highestBidder ; uint highestBid ; mapping ( address => uint ) refunds ; function bid () payable external { require ( msg.value >= highestBid ); if ( highestBidder != address ( 0 )) { refunds [ highestBidder ] += highestBid ; // record the refund that this user can claim } highestBidder = msg.sender ; highestBid = msg.value ; } function withdrawRefund () external { uint refund = refunds [ msg.sender ]; refunds [ msg.sender ] = 0 ; ( bool success , ) = msg.sender . call . value ( refund )( \"\" ); require ( success ); } } See SWC-128 Don't delegatecall to untrusted code \u00b6 The delegatecall function is used to call functions from other contracts as if they belong to the caller contract. Thus the callee may change the state of the calling address. This may be insecure. An example below shows how using delegatecall can lead to the destruction of the contract and loss of its balance. contract Destructor { function doWork () external { selfdestruct ( 0 ); } } contract Worker { function doWork ( address _internalWorker ) public { // unsafe _internalWorker . delegatecall ( bytes4 ( keccak256 ( \"doWork()\" ))); } } If Worker.doWork() is called with the address of the deployed Destructor contract as an argument, the Worker contract will self-destruct. Delegate execution only to trusted contracts, and never to a user supplied address . Warning Don't assume contracts are created with zero balance An attacker can send ether to the address of a contract before it is created. Contracts should not assume that their initial state contains a zero balance. See issue 61 for more details. See SWC-112","title":"External Calls"},{"location":"development-recommendations/general/external-calls/#use-caution-when-making-external-calls","text":"Calls to untrusted contracts can introduce several unexpected risks or errors. External calls may execute malicious code in that contract or any other contract that it depends upon. As such, every external call should be treated as a potential security risk. When it is not possible, or undesirable to remove external calls, use the recommendations in the rest of this section to minimize the danger.","title":"Use caution when making external calls"},{"location":"development-recommendations/general/external-calls/#mark-untrusted-contracts","text":"When interacting with external contracts, name your variables, methods, and contract interfaces in a way that makes it clear that interacting with them is potentially unsafe. This applies to your own functions that call external contracts. // bad Bank . withdraw ( 100 ); // Unclear whether trusted or untrusted function makeWithdrawal ( uint amount ) { // Isn't clear that this function is potentially unsafe Bank . withdraw ( amount ); } // good UntrustedBank . withdraw ( 100 ); // untrusted external call TrustedBank . withdraw ( 100 ); // external but trusted bank contract maintained by XYZ Corp function makeUntrustedWithdrawal ( uint amount ) { UntrustedBank . withdraw ( amount ); }","title":"Mark untrusted contracts"},{"location":"development-recommendations/general/external-calls/#avoid-state-changes-after-external-calls","text":"Whether using raw calls (of the form someAddress.call() ) or contract calls (of the form ExternalContract.someMethod() ), assume that malicious code might execute. Even if ExternalContract is not malicious, malicious code can be executed by any contracts it calls. One particular danger is malicious code may hijack the control flow, leading to vulnerabilities due to reentrancy. (See Reentrancy for a fuller discussion of this problem). If you are making a call to an untrusted external contract, avoid state changes after the call . This pattern is also sometimes known as the checks-effects-interactions pattern . See SWC-107","title":"Avoid state changes after external calls"},{"location":"development-recommendations/general/external-calls/#dont-use-transfer-or-send","text":".transfer() and .send() forward exactly 2,300 gas to the recipient. The goal of this hardcoded gas stipend was to prevent reentrancy vulnerabilities , but this only makes sense under the assumption that gas costs are constant. Recently EIP 1884 was included in the Istanbul hard fork. One of the changes included in EIP 1884 is an increase to the gas cost of the SLOAD operation, causing a contract's fallback function to cost more than 2300 gas. It's recommended to stop using .transfer() and .send() and instead use .call() . // bad contract Vulnerable { function withdraw(uint256 amount) external { // This forwards 2300 gas, which may not be enough if the recipient // is a contract and gas costs change. msg.sender.transfer(amount); } } // good contract Fixed { function withdraw(uint256 amount) external { // This forwards all available gas. Be sure to check the return value! (bool success, ) = msg.sender.call.value(amount)(\"\"); require(success, \"Transfer failed.\"); } } Note that .call() does nothing to mitigate reentrancy attacks, so other precautions must be taken. To prevent reentrancy attacks, it is recommended that you use the checks-effects-interactions pattern .","title":"Don't use transfer() or send()."},{"location":"development-recommendations/general/external-calls/#handle-errors-in-external-calls","text":"Solidity offers low-level call methods that work on raw addresses: address.call() , address.callcode() , address.delegatecall() , and address.send() . These low-level methods never throw an exception, but will return false if the call encounters an exception. On the other hand, contract calls (e.g., ExternalContract.doSomething() ) will automatically propagate a throw (for example, ExternalContract.doSomething() will also throw if doSomething() throws). If you choose to use the low-level call methods, make sure to handle the possibility that the call will fail, by checking the return value. // bad someAddress . send ( 55 ); someAddress . call . value ( 55 )( \"\" ); // this is doubly dangerous, as it will forward all remaining gas and doesn't check for result someAddress . call . value ( 100 )( bytes4 ( sha3 ( \"deposit()\" ))); // if deposit throws an exception, the raw call() will only return false and transaction will NOT be reverted // good ( bool success , ) = someAddress . call . value ( 55 )( \"\" ); if ( ! success ) { // handle failure code } ExternalContract ( someAddress ). deposit . value ( 100 )(); See SWC-104","title":"Handle errors in external calls"},{"location":"development-recommendations/general/external-calls/#favor-pull-over-push-for-external-calls","text":"External calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is often better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically. (This also reduces the chance of problems with the gas limit .) Avoid combining multiple ether transfers in a single transaction. // bad contract auction { address highestBidder ; uint highestBid ; function bid () payable { require ( msg.value >= highestBid ); if ( highestBidder != address ( 0 )) { ( bool success , ) = highestBidder . call . value ( highestBid )( \"\" ); require ( success ); // if this call consistently fails, no one else can bid } highestBidder = msg.sender ; highestBid = msg.value ; } } // good contract auction { address highestBidder ; uint highestBid ; mapping ( address => uint ) refunds ; function bid () payable external { require ( msg.value >= highestBid ); if ( highestBidder != address ( 0 )) { refunds [ highestBidder ] += highestBid ; // record the refund that this user can claim } highestBidder = msg.sender ; highestBid = msg.value ; } function withdrawRefund () external { uint refund = refunds [ msg.sender ]; refunds [ msg.sender ] = 0 ; ( bool success , ) = msg.sender . call . value ( refund )( \"\" ); require ( success ); } } See SWC-128","title":"Favor pull over push for external calls"},{"location":"development-recommendations/general/external-calls/#dont-delegatecall-to-untrusted-code","text":"The delegatecall function is used to call functions from other contracts as if they belong to the caller contract. Thus the callee may change the state of the calling address. This may be insecure. An example below shows how using delegatecall can lead to the destruction of the contract and loss of its balance. contract Destructor { function doWork () external { selfdestruct ( 0 ); } } contract Worker { function doWork ( address _internalWorker ) public { // unsafe _internalWorker . delegatecall ( bytes4 ( keccak256 ( \"doWork()\" ))); } } If Worker.doWork() is called with the address of the deployed Destructor contract as an argument, the Worker contract will self-destruct. Delegate execution only to trusted contracts, and never to a user supplied address . Warning Don't assume contracts are created with zero balance An attacker can send ether to the address of a contract before it is created. Contracts should not assume that their initial state contains a zero balance. See issue 61 for more details. See SWC-112","title":"Don't delegatecall to untrusted code"},{"location":"development-recommendations/general/force-feeding/","text":"Beware of coding an invariant that strictly checks the balance of a contract. An attacker can forcibly send ether to any account and this cannot be prevented (not even with a fallback function that does a revert() ). The attacker can do this by creating a contract, funding it with 1 wei, and invoking selfdestruct(victimAddress) . No code is invoked in victimAddress , so it cannot be prevented. This is also true for block reward which is sent to the address of the miner, which can be any arbitrary address. Also, since contract addresses can be precomputed, ether can be sent to an address before the contract is deployed. See SWC-132","title":"Force-feeding Ether"},{"location":"development-recommendations/general/negative-int/","text":"Solidity provides several types to work with signed integers. Like in most programming languages, in Solidity a signed integer with N bits can represent values from -2^(N-1) to 2^(N-1)-1 . This means that there is no positive equivalent for the MIN_INT . Negation is implemented as finding the two's complement of a number, so the negation of the most negative number will result in the same number . This is true for all signed integer types in Solidity ( int8 , int16 , ..., int256 ). contract Negation { function negate8 ( int8 _i ) public pure returns ( int8 ) { return - _i ; } function negate16 ( int16 _i ) public pure returns ( int16 ) { return - _i ; } int8 public a = negate8 ( - 128 ); // -128 int16 public b = negate16 ( - 128 ); // 128 int16 public c = negate16 ( - 32768 ); // -32768 } One way to handle this is to check the value of a variable before negation and throw if it's equal to the MIN_INT . Another option is to make sure that the most negative number will never be achieved by using a type with a higher capacity (e.g. int32 instead of int16 ). A similar issue with int types occurs when MIN_INT is multiplied or divided by -1 .","title":"Negation of Signed Integers"},{"location":"development-recommendations/general/participants/","text":"Do not make refund or claim processes dependent on a specific party performing a particular action with no other way of getting the funds out. For example, in a rock-paper-scissors game, one common mistake is to not make a payout until both players submit their moves; however, a malicious player can \"grief\" the other by simply never submitting their move - in fact, if a player sees the other player's revealed move and determines that they lost, they have no reason to submit their own move at all. This issue may also arise in the context of state channel settlement. When such situations are an issue, (1) provide a way of circumventing non-participating participants, perhaps through a time limit, and (2) consider adding economic incentive for participants to submit information in all of the situations in which they are supposed to do so.","title":"Unreliable Participants"},{"location":"development-recommendations/general/public-data/","text":"Many applications require submitted data to be private up until some point in time in order to work. Games (eg. on-chain rock-paper-scissors) and auction mechanisms (eg. sealed-bid Vickrey auctions ) are two major categories of examples. If you are building an application where privacy is an issue, make sure you avoid requiring users to publish information too early. The best strategy is to use commitment schemes with separate phases: first commit using the hash of the values and in a later phase revealing the values. Examples: In rock paper scissors, require both players to submit a hash of their intended move first, then require both players to submit their move; if the submitted move does not match the hash throw it out. In an auction, require players to submit a hash of their bid value in an initial phase (along with a deposit greater than their bid value), and then submit their auction bid value in the second phase. When developing an application that depends on a random number generator, the order should always be (1) players submit moves, (2) random number generated, (3) players paid out. The method by which random numbers are generated is itself an area of active research; current best-in-class solutions include Bitcoin block headers (verified through http://btcrelay.org ), hash-commit-reveal schemes (ie. one party generates a number, publishes its hash to \"commit\" to the value, and then reveals the value later) and RANDAO . As Ethereum is a deterministic protocol, no variable within the protocol could be used as an unpredictable random number. Also, be aware that miners are in some extent in control of the block.blockhash() value * .","title":"Public on-chain Data"},{"location":"development-recommendations/precautions/circuit-breakers/","text":"Circuit breakers stop execution if certain conditions are met, and can be useful when new errors are discovered. For example, most actions may be suspended in a contract if a bug is discovered, and the only action now active is a withdrawal. You can either give certain trusted parties the ability to trigger the circuit breaker or else have programmatic rules that automatically trigger the certain breaker when certain conditions are met. Example: bool private stopped = false ; address private owner ; modifier isAdmin () { require ( msg.sender == owner ); _ ; } function toggleContractActive () isAdmin public { // You can add an additional modifier that restricts stopping a contract to be based on another action, such as a vote of users stopped = ! stopped ; } modifier stopInEmergency { if ( ! stopped ) _ ; } modifier onlyInEmergency { if ( stopped ) _ ; } function deposit () stopInEmergency public { // some code } function withdraw () onlyInEmergency public { // some code }","title":"Circuit Breakers"},{"location":"development-recommendations/precautions/deployment/","text":"Contracts should have a substantial and prolonged testing period - before substantial money is put at risk. At minimum, you should: Have a full test suite with 100% test coverage (or close to it) Deploy on your own testnet Deploy on the public testnet with substantial testing and bug bounties Exhaustive testing should allow various players to interact with the contract at volume Deploy on the mainnet in beta, with limits to the amount at risk Automatic Deprecation \u00b6 During testing, you can force an automatic deprecation by preventing any actions, after a certain time period. For example, an alpha contract may work for several weeks and then automatically shut down all actions, except for the final withdrawal. modifier isActive () { require ( block.number <= SOME_BLOCK_NUMBER ); _ ; } function deposit () public isActive { // some code } function withdraw () public { // some code } Restrict amount of Ether per user/contract \u00b6 In the early stages, you can restrict the amount of Ether for any user (or for the entire contract) - reducing the risk.","title":"Deployment"},{"location":"development-recommendations/precautions/deployment/#automatic-deprecation","text":"During testing, you can force an automatic deprecation by preventing any actions, after a certain time period. For example, an alpha contract may work for several weeks and then automatically shut down all actions, except for the final withdrawal. modifier isActive () { require ( block.number <= SOME_BLOCK_NUMBER ); _ ; } function deposit () public isActive { // some code } function withdraw () public { // some code }","title":"Automatic Deprecation"},{"location":"development-recommendations/precautions/deployment/#restrict-amount-of-ether-per-usercontract","text":"In the early stages, you can restrict the amount of Ether for any user (or for the entire contract) - reducing the risk.","title":"Restrict amount of Ether per user/contract"},{"location":"development-recommendations/precautions/general/","text":"As we discussed in the General Philosophy section, it is not enough to protect yourself against the known attacks. Since the cost of failure on a blockchain can be very high, you must also adapt the way you write software, to account for that risk. The approach we advocate is to \"prepare for failure\". It is impossible to know in advance whether your code is secure. However, you can architect your contracts in a way that allows them to fail gracefully, and with minimal damage. This section presents a variety of techniques that will help you prepare for failure. Note: There's always a risk when you add a new component to your system. A badly designed fail-safe could itself become a vulnerability - as can the interaction between a number of well-designed fail-safes. Be thoughtful about each technique you use in your contracts, and consider carefully how they work together to create a robust system.","title":"General"},{"location":"development-recommendations/precautions/rate-limiting/","text":"Rate limiting halts or requires approval for substantial changes. For example, a depositor may only be allowed to withdraw a certain amount or percentage of total deposits over a certain time period (e.g., max 100 ether over 1 day) - additional withdrawals in that time period may fail or require some sort of special approval. Or the rate limit could be at the contract level, with only a certain amount of tokens issued by the contract over a time period. Example: uint internal period ; // how many blocks before limit resets uint internal limit ; // max ether to withdraw per period uint internal currentPeriodEnd ; // block which the current period ends at uint internal currentPeriodAmount ; // amount already withdrawn this period constructor ( uint _period , uint _limit ) public { period = _period ; limit = _limit ; currentPeriodEnd = block.number + period ; } function withdraw ( uint amount ) public { // Update period before proceeding updatePeriod (); // Prevent overflow uint totalAmount = currentPeriodAmount + amount ; require ( totalAmount >= currentPeriodAmount , 'overflow' ); // Disallow withdraws that exceed current rate limit require ( currentPeriodAmount + amount < limit , 'exceeds period limit' ); currentPeriodAmount += amount ; msg.sender . transfer ( amount ); } function updatePeriod () internal { if ( currentPeriodEnd < block.number ) { currentPeriodEnd = block.number + period ; currentPeriodAmount = 0 ; } }","title":"Rate Limiting"},{"location":"development-recommendations/precautions/safe-haven/","text":"Some tips for running bounty programs: Decide which currency bounties will be distributed in (BTC and/or ETH) Decide on an estimated total budget for bounty rewards From the budget, determine three tiers of rewards: smallest reward you are willing to give out highest reward that's usually awardable an extra range to be awarded in case of very severe vulnerabilities Determine who the bounty judges are (3 may be ideal typically) Lead developer should probably be one of the bounty judges When a bug report is received, the lead developer, with advice from judges, should evaluate the severity of the bug Work at this stage should be in a private repo, and the issue filed on Github If it's a bug that should be fixed, in the private repo, a developer should write a test case, which should fail and thus confirm the bug Developer should implement the fix and ensure the test now passes; writing additional tests as needed Show the bounty hunter the fix; merge the fix back to the public repo is one way Determine if bounty hunter has any other feedback about the fix Bounty judges determine the size of the reward, based on their evaluation of both the likelihood and impact of the bug. Keep bounty participants informed throughout the process, and then strive to avoid delays in sending them their reward For an example of the three tiers of rewards, see Ethereum's Bounty Program : The value of rewards paid out will vary depending on severity of impact. Rewards for minor 'harmless' bugs start at 0.05 BTC. Major bugs, for example leading to consensus issues, will be rewarded up to 5 BTC. Much higher rewards are possible (up to 25 BTC) in case of very severe vulnerabilities.","title":"Safe Haven"},{"location":"development-recommendations/precautions/speed-bumps/","text":"Speed bumps slow down actions, so that if malicious actions occur, there is time to recover. For example, The DAO required 27 days between a successful request to split the DAO and the ability to do so. This ensured the funds were kept within the contract, increasing the likelihood of recovery. In the case of the DAO, there was no effective action that could be taken during the time given by the speed bump, but in combination with our other techniques, they can be quite effective. Example: struct RequestedWithdrawal { uint amount ; uint time ; } mapping ( address => uint ) private balances ; mapping ( address => RequestedWithdrawal ) private requestedWithdrawals ; uint constant withdrawalWaitPeriod = 28 days ; // 4 weeks function requestWithdrawal () public { if ( balances [ msg.sender ] > 0 ) { uint amountToWithdraw = balances [ msg.sender ]; balances [ msg.sender ] = 0 ; // for simplicity, we withdraw everything; // presumably, the deposit function prevents new deposits when withdrawals are in progress requestedWithdrawals [ msg.sender ] = RequestedWithdrawal ({ amount : amountToWithdraw , time : block.timestamp }); } } function withdraw () public { if ( requestedWithdrawals [ msg.sender ]. amount > 0 && block.timestamp > requestedWithdrawals [ msg.sender ]. time + withdrawalWaitPeriod ) { uint amountToWithdraw = requestedWithdrawals [ msg.sender ]. amount ; requestedWithdrawals [ msg.sender ]. amount = 0 ; require ( msg.sender . send ( amountToWithdraw )); } }","title":"Speed Bumps"},{"location":"development-recommendations/precautions/upgradeability/","text":"Warning Smart Contract upgradeability is an active area of research. There are many important questions, and risks related to smart contract upgradeability. Do your research into the state of the art. We welcome discussion on the related issue . Code will need to be changed if errors are discovered or if improvements need to be made. It is no good to discover a bug, but have no way to deal with it. Designing an effective upgrade system for smart contracts is an area of active research, and we won't be able to cover all of the complications in this document. However, two basic approaches are most commonly used. The simpler of the two is to have a registry contract that holds the address of the latest version of the contract. A more seamless approach for contract users is to have a contract that forwards calls and data onto the latest version of the contract. Whatever the technique, it's important to have modularization and good separation between components, so that code changes do not break functionality, orphan data, or require substantial costs to port. In particular, it is usually beneficial to separate complex logic from your data storage, so that you do not have to recreate all of the data in order to change the functionality. It's also critical to have a secure way for parties to decide to upgrade the code. Depending on your contract, code changes may need to be approved by a single trusted party, a group of members, or a vote of the full set of stakeholders. If this process can take some time, you will want to consider if there are other ways to react more quickly in case of an attack, such as an emergency stop or circuit-breaker . Regardless of your approach, it is important to have some way to upgrade your contracts, or they will become unusable when the inevitable bugs are discovered in them. Example 1: Use a registry contract to store the latest version of a contract \u00b6 In this example, the calls aren't forwarded, so users should fetch the current address each time before interacting with it. pragma solidity ^ 0.5 . 0 ; contract SomeRegister { address backendContract ; address [] previousBackends ; address owner ; constructor () { owner = msg.sender ; } modifier onlyOwner () { require ( msg.sender == owner ) _ ; } function changeBackend ( address newBackend ) public onlyOwner () returns ( bool ) { if ( newBackend != address ( 0 ) && newBackend != backendContract ) { previousBackends . push ( backendContract ); backendContract = newBackend ; return true ; } return false ; } } There are two main disadvantages to this approach: Users must always look up the current address, and anyone who fails to do so risks using an old version of the contract You will need to think carefully about how to deal with the contract data when you replace the contract The alternate approach is to have a contract forward calls and data to the latest version of the contract: Example 2: Use a DELEGATECALL to forward data and calls \u00b6 This approach relies on using the fallback function (in Relay contract) to forward the calls to a target contract ( LogicContract ) using delegatecall . Remember that delegatecall is a special function in Solidity that executes the logic of the called address ( LogicContract ) in the context of the calling contract ( Relay ), so \"storage, current address and balance still refer to the calling contract , only the code is taken from the called address\" . pragma solidity ^ 0.5 . 0 ; contract Relay { address public currentVersion ; address public owner ; modifier onlyOwner () { require ( msg.sender == owner ); _ ; } constructor ( address initAddr ) { require ( initAddr != address ( 0 )); currentVersion = initAddr ; owner = msg.sender ; // this owner may be another contract with multisig, not a single contract owner } function changeContract ( address newVersion ) public onlyOwner () { require ( newVersion != address ( 0 )); currentVersion = newVersion ; } fallback () external payable { ( bool success , ) = address ( currentVersion ). delegatecall ( msg.data ); require ( success ); } } contract LogicContract { address public currentVersion ; address public owner ; uint public counter ; function incrementCounter () { counter ++ ; } } This simple version of the pattern cannot return values from LogicContract 's functions, only forward them, which limits its applicability. More complex implementations attempt to solve this with in-line assembly code and a registry of return sizes. They are commonly referred to as Proxy Patterns , but are also known as Router , Dispatcher and Relay. Each implementation variant introduces a different set of complexity, risks and limitations. You must be extremely careful with how you store data with this method. If your new contract has a different storage layout than the first, your data may end up corrupted. When using more complex implementations of delegatecall , you should carefully consider and understand*: How the EVM handles the layout of state variables in storage , including packing multiple variables into a single storage slot if possible How and why the order of inheritance impacts the storage layout Why the called contract ( LogicContract ) must have the same storage layout of the calling contract ( Relay ), and only append new variables to the storage (see Background on delegatecall ) Why a new version of the called contract ( LogicContract ) must have the same storage layout as the previous version , and only append new variables to the storage How a contract's constructor can affect upgradeability How the ABI specifies function selectors and how function-name collision can be used to exploit a contract that uses delegatecall How delegatecall to a non-existent contract will return true even if the called contract does not exist. For more details see Breaking the proxy pattern and Solidity docs on Error handling . Remember the importance of immutability to achieve truslessness * Extended from Proxy pattern recommendations section","title":"Upgradeability"},{"location":"development-recommendations/precautions/upgradeability/#example-1-use-a-registry-contract-to-store-the-latest-version-of-a-contract","text":"In this example, the calls aren't forwarded, so users should fetch the current address each time before interacting with it. pragma solidity ^ 0.5 . 0 ; contract SomeRegister { address backendContract ; address [] previousBackends ; address owner ; constructor () { owner = msg.sender ; } modifier onlyOwner () { require ( msg.sender == owner ) _ ; } function changeBackend ( address newBackend ) public onlyOwner () returns ( bool ) { if ( newBackend != address ( 0 ) && newBackend != backendContract ) { previousBackends . push ( backendContract ); backendContract = newBackend ; return true ; } return false ; } } There are two main disadvantages to this approach: Users must always look up the current address, and anyone who fails to do so risks using an old version of the contract You will need to think carefully about how to deal with the contract data when you replace the contract The alternate approach is to have a contract forward calls and data to the latest version of the contract:","title":"Example 1: Use a registry contract to store the latest version of a contract"},{"location":"development-recommendations/precautions/upgradeability/#example-2-use-a-delegatecall-to-forward-data-and-calls","text":"This approach relies on using the fallback function (in Relay contract) to forward the calls to a target contract ( LogicContract ) using delegatecall . Remember that delegatecall is a special function in Solidity that executes the logic of the called address ( LogicContract ) in the context of the calling contract ( Relay ), so \"storage, current address and balance still refer to the calling contract , only the code is taken from the called address\" . pragma solidity ^ 0.5 . 0 ; contract Relay { address public currentVersion ; address public owner ; modifier onlyOwner () { require ( msg.sender == owner ); _ ; } constructor ( address initAddr ) { require ( initAddr != address ( 0 )); currentVersion = initAddr ; owner = msg.sender ; // this owner may be another contract with multisig, not a single contract owner } function changeContract ( address newVersion ) public onlyOwner () { require ( newVersion != address ( 0 )); currentVersion = newVersion ; } fallback () external payable { ( bool success , ) = address ( currentVersion ). delegatecall ( msg.data ); require ( success ); } } contract LogicContract { address public currentVersion ; address public owner ; uint public counter ; function incrementCounter () { counter ++ ; } } This simple version of the pattern cannot return values from LogicContract 's functions, only forward them, which limits its applicability. More complex implementations attempt to solve this with in-line assembly code and a registry of return sizes. They are commonly referred to as Proxy Patterns , but are also known as Router , Dispatcher and Relay. Each implementation variant introduces a different set of complexity, risks and limitations. You must be extremely careful with how you store data with this method. If your new contract has a different storage layout than the first, your data may end up corrupted. When using more complex implementations of delegatecall , you should carefully consider and understand*: How the EVM handles the layout of state variables in storage , including packing multiple variables into a single storage slot if possible How and why the order of inheritance impacts the storage layout Why the called contract ( LogicContract ) must have the same storage layout of the calling contract ( Relay ), and only append new variables to the storage (see Background on delegatecall ) Why a new version of the called contract ( LogicContract ) must have the same storage layout as the previous version , and only append new variables to the storage How a contract's constructor can affect upgradeability How the ABI specifies function selectors and how function-name collision can be used to exploit a contract that uses delegatecall How delegatecall to a non-existent contract will return true even if the called contract does not exist. For more details see Breaking the proxy pattern and Solidity docs on Error handling . Remember the importance of immutability to achieve truslessness * Extended from Proxy pattern recommendations section","title":"Example 2: Use a DELEGATECALL to forward data and calls"},{"location":"development-recommendations/solidity-specific/abstract-vs-interfaces/","text":"Be aware of the tradeoffs between abstract contracts and interfaces . Both interfaces and abstract contracts provide one with a customizable and re-usable approach for smart contracts. Interfaces, which were introduced in Solidity 0.4.11, are similar to abstract contracts but cannot have any functions implemented. Interfaces also have limitations such as not being able to access storage or inherit from other interfaces which generally makes abstract contracts more practical. Although, interfaces are certainly useful for designing contracts prior to implementation. Additionally, it is important to keep in mind that if a contract inherits from an abstract contract it must implement all non-implemented functions via overriding or it will be abstract as well.","title":"Abstract vs Interfaces"},{"location":"development-recommendations/solidity-specific/assert-require-revert/","text":"Enforce invariants with assert() \u00b6 An assert guard triggers when an assertion fails - such as an invariant property changing. For example, the token to ether issuance ratio, in a token issuance contract, may be fixed. You can verify that this is the case at all times with an assert() . Assert guards should often be combined with other techniques, such as pausing the contract and allowing upgrades. (Otherwise, you may end up stuck, with an assertion that is always failing.) Example: contract Token { mapping ( address => uint ) public balanceOf ; uint public totalSupply ; function deposit () public payable { balanceOf [ msg.sender ] += msg.value ; totalSupply += msg.value ; assert ( address ( this ). balance >= totalSupply ); } } Note that the assertion is not a strict equality of the balance because the contract can be forcibly sent ether without going through the deposit() function! Use assert() , require() , revert() properly \u00b6 Info The convenience functions assert and require can be used to check for conditions and throw an exception if the condition is not met. The assert function should only be used to test for internal errors, and to check invariants. The require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts. * Following this paradigm allows formal analysis tools to verify that the invalid opcode can never be reached: meaning no invariants in the code are violated and that the code is formally verified. pragma solidity ^ 0.5 . 0 ; contract Sharer { function sendHalf ( address payable addr ) public payable returns ( uint balance ) { require ( msg.value % 2 == 0 , \"Even value required.\" ); //Require() can have an optional message string uint balanceBeforeTransfer = address ( this ). balance ; ( bool success , ) = addr . call . value ( msg.value / 2 )( \"\" ); require ( success ); // Since we reverted if the transfer failed, there should be // no way for us to still have half of the money. assert ( address ( this ). balance == balanceBeforeTransfer - msg.value / 2 ); // used for internal error checking return address ( this ). balance ; } } See SWC-110 & SWC-123","title":"Assert, Require, Revert"},{"location":"development-recommendations/solidity-specific/assert-require-revert/#enforce-invariants-with-assert","text":"An assert guard triggers when an assertion fails - such as an invariant property changing. For example, the token to ether issuance ratio, in a token issuance contract, may be fixed. You can verify that this is the case at all times with an assert() . Assert guards should often be combined with other techniques, such as pausing the contract and allowing upgrades. (Otherwise, you may end up stuck, with an assertion that is always failing.) Example: contract Token { mapping ( address => uint ) public balanceOf ; uint public totalSupply ; function deposit () public payable { balanceOf [ msg.sender ] += msg.value ; totalSupply += msg.value ; assert ( address ( this ). balance >= totalSupply ); } } Note that the assertion is not a strict equality of the balance because the contract can be forcibly sent ether without going through the deposit() function!","title":"Enforce invariants with assert()"},{"location":"development-recommendations/solidity-specific/assert-require-revert/#use-assert-require-revert-properly","text":"Info The convenience functions assert and require can be used to check for conditions and throw an exception if the condition is not met. The assert function should only be used to test for internal errors, and to check invariants. The require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts. * Following this paradigm allows formal analysis tools to verify that the invalid opcode can never be reached: meaning no invariants in the code are violated and that the code is formally verified. pragma solidity ^ 0.5 . 0 ; contract Sharer { function sendHalf ( address payable addr ) public payable returns ( uint balance ) { require ( msg.value % 2 == 0 , \"Even value required.\" ); //Require() can have an optional message string uint balanceBeforeTransfer = address ( this ). balance ; ( bool success , ) = addr . call . value ( msg.value / 2 )( \"\" ); require ( success ); // Since we reverted if the transfer failed, there should be // no way for us to still have half of the money. assert ( address ( this ). balance == balanceBeforeTransfer - msg.value / 2 ); // used for internal error checking return address ( this ). balance ; } } See SWC-110 & SWC-123","title":"Use assert(), require(), revert() properly"},{"location":"development-recommendations/solidity-specific/complex-inheritance/","text":"When utilizing multiple inheritance in Solidity, it is important to understand how the compiler composes the inheritance graph. contract Final { uint public a ; function Final ( uint f ) public { a = f ; } } contract B is Final { int public fee ; function B ( uint f ) Final ( f ) public { } function setFee () public { fee = 3 ; } } contract C is Final { int public fee ; function C ( uint f ) Final ( f ) public { } function setFee () public { fee = 5 ; } } contract A is B , C { function A () public B ( 3 ) C ( 5 ) { setFee (); } } When a contract is deployed, the compiler will linearize the inheritance from right to left (after the keyword is the parents are listed from the most base-like to the most derived). Here is contract A's linearization: Final \\<- B \\<- C \\<- A The consequence of the linearization will yield a fee value of 5, since C is the most derived contract. This may seem obvious, but imagine scenarios where C is able to shadow crucial functions, reorder boolean clauses, and cause the developer to write exploitable contracts. Static analysis currently does not raise issue with overshadowed functions, so it must be manually inspected. For more on security and inheritance, check out this article To help contribute, Solidity's Github has a project with all inheritance-related issues. See SWC-125","title":"Complex Inheritance"},{"location":"development-recommendations/solidity-specific/event-monitoring/","text":"It can be useful to have a way to monitor the contract's activity after it was deployed. One way to accomplish this is to look at all transactions of the contract, however that may be insufficient, as message calls between contracts are not recorded in the blockchain. Moreover, it shows only the input parameters, not the actual changes being made to the state. Also, events could be used to trigger functions in the user interface. contract Charity { mapping ( address => uint ) balances ; function donate () payable public { balances [ msg.sender ] += msg.value ; } } contract Game { function buyCoins () payable public { // 5% goes to charity charity . donate . value ( msg.value / 20 )(); } } Here, Game contract will make an internal call to Charity.donate() . This transaction won't appear in the external transaction list of Charity , but only visible in the internal transactions. An event is a convenient way to log something that happened in the contract. Events that were emitted stay in the blockchain along with the other contract data and they are available for future audit. Here is an improvement to the example above, using events to provide a history of the Charity's donations. contract Charity { // define event event LogDonate ( uint _amount ); mapping ( address => uint ) balances ; function donate () payable public { balances [ msg.sender ] += msg.value ; // emit event emit LogDonate ( msg.value ); } } contract Game { function buyCoins () payable public { // 5% goes to charity charity . donate . value ( msg.value / 20 )(); } } Here, all transactions that go through the Charity contract, either directly or not, will show up in the event list of that contract along with the amount of donated money. Prefer newer Solidity constructs Prefer constructs/aliases such as selfdestruct (over suicide ) and keccak256 (over sha3 ). Patterns like require(msg.sender.send(1 ether)) can also be simplified to using transfer() , as in msg.sender.transfer(1 ether) . Check out Solidity Change log for more similar changes.","title":"Event Monitoring"},{"location":"development-recommendations/solidity-specific/extcodesize-checks/","text":"Avoid using extcodesize to check for Externally Owned Accounts. The following modifier (or a similar check) is often used to verify whether a call was made from an externally owned account (EOA) or a contract account: // bad modifier isNotContract ( address _a ) { uint size ; assembly { size := extcodesize ( _a ) } require ( size == 0 ) ; _ ; } The idea is straightforward: if an address contains code, it's not an EOA but a contract account. However, a contract does not have source code available during construction . This means that while the constructor is running, it can make calls to other contracts, but extcodesize for its address returns zero. Below is a minimal example that shows how this check can be circumvented: contract OnlyForEOA { uint public flag ; // bad modifier isNotContract ( address _a ){ uint len ; assembly { len := extcodesize ( _a ) } require ( len == 0 ) ; _ ; } function setFlag ( uint i ) public isNotContract ( msg.sender ){ flag = i ; } } contract FakeEOA { constructor ( address _a ) public { OnlyForEOA c = OnlyForEOA ( _a ); c . setFlag ( 1 ); } } Because contract addresses can be pre-computed, this check could also fail if it checks an address which is empty at block n , but which has a contract deployed to it at some block greater than n . This issue is nuanced. If your goal is to prevent other contracts from being able to call your contract, the extcodesize check is probably sufficient. An alternative approach is to check the value of (tx.origin == msg.sender) , though this also has drawbacks . There may be other situations in which the extcodesize check serves your purpose. Describing all of them here is out of scope. Understand the underlying behaviors of the EVM and use your Judgement.","title":"EXTCODESIZE Checks"},{"location":"development-recommendations/solidity-specific/fallback-functions/","text":"Keep fallback functions simple \u00b6 Fallback functions are called when a contract is sent a message with no arguments (or when no function matches), and only has access to 2,300 gas when called from a .send() or .transfer() . If you wish to be able to receive Ether from a .send() or .transfer() , the most you can do in a fallback function is log an event. Use a proper function if a computation of more gas is required. // bad function () payable { balances [ msg.sender ] += msg.value ; } // good function deposit () payable external { balances [ msg.sender ] += msg.value ; } function () payable { require ( msg.data . length == 0 ); emit LogDepositReceived ( msg.sender ); } Check data length in fallback functions \u00b6 Since the fallback functions is not only called for plain ether transfers (without data) but also when no other function matches, you should check that the data is empty if the fallback function is intended to be used only for the purpose of logging received Ether. Otherwise, callers will not notice if your contract is used incorrectly and functions that do not exist are called. // bad function () payable { emit LogDepositReceived ( msg.sender ); } // good function () payable { require ( msg.data . length == 0 ); emit LogDepositReceived ( msg.sender ); }","title":"Fallback Functions"},{"location":"development-recommendations/solidity-specific/fallback-functions/#keep-fallback-functions-simple","text":"Fallback functions are called when a contract is sent a message with no arguments (or when no function matches), and only has access to 2,300 gas when called from a .send() or .transfer() . If you wish to be able to receive Ether from a .send() or .transfer() , the most you can do in a fallback function is log an event. Use a proper function if a computation of more gas is required. // bad function () payable { balances [ msg.sender ] += msg.value ; } // good function deposit () payable external { balances [ msg.sender ] += msg.value ; } function () payable { require ( msg.data . length == 0 ); emit LogDepositReceived ( msg.sender ); }","title":"Keep fallback functions simple"},{"location":"development-recommendations/solidity-specific/fallback-functions/#check-data-length-in-fallback-functions","text":"Since the fallback functions is not only called for plain ether transfers (without data) but also when no other function matches, you should check that the data is empty if the fallback function is intended to be used only for the purpose of logging received Ether. Otherwise, callers will not notice if your contract is used incorrectly and functions that do not exist are called. // bad function () payable { emit LogDepositReceived ( msg.sender ); } // good function () payable { require ( msg.data . length == 0 ); emit LogDepositReceived ( msg.sender ); }","title":"Check data length in fallback functions"},{"location":"development-recommendations/solidity-specific/integer-division/","text":"All integer division rounds down to the nearest integer. If you need more precision, consider using a multiplier, or store both the numerator and denominator. (In the future, Solidity will have a fixed-point type, which will make this easier.) // bad uint x = 5 / 2 ; // Result is 2, all integer division rounds DOWN to the nearest integer Using a multiplier prevents rounding down, this multiplier needs to be accounted for when working with x in the future: // good uint multiplier = 10 ; uint x = ( 5 * multiplier ) / 2 ; Storing the numerator and denominator means you can calculate the result of numerator/denominator off-chain: // good uint numerator = 5 ; uint denominator = 2 ;","title":"Integer Division"},{"location":"development-recommendations/solidity-specific/interface-types/","text":"When a function takes a contract address as an argument, it is better to pass an interface or contract type rather than a raw address . If the function is called elsewhere within the source code, the compiler will provide additional type safety guarantees. Here we see two alternatives: contract Validator { function validate ( uint ) external returns ( bool ); } contract TypeSafeAuction { // good function validateBet ( Validator _validator , uint _value ) internal returns ( bool ) { bool valid = _validator . validate ( _value ); return valid ; } } contract TypeUnsafeAuction { // bad function validateBet ( address _addr , uint _value ) internal returns ( bool ) { Validator validator = Validator ( _addr ); bool valid = validator . validate ( _value ); return valid ; } } The benefits of using the TypeSafeAuction contract above can then be seen from the following example. If validateBet() is called with an address argument, or a contract type other than Validator , the compiler will throw this error: contract NonValidator {} contract Auction is TypeSafeAuction { NonValidator nonValidator ; function bet ( uint _value ) { bool valid = validateBet ( nonValidator , _value ); // TypeError: Invalid type for argument in function call. // Invalid implicit conversion from contract NonValidator // to contract Validator requested. } }","title":"Interface Types"},{"location":"development-recommendations/solidity-specific/locking-pragmas/","text":"Contracts should be deployed with the same compiler version and flags that they have been tested the most with. Locking the pragma helps ensure that contracts do not accidentally get deployed using, for example, the latest compiler which may have higher risks of undiscovered bugs. Contracts may also be deployed by others and the pragma indicates the compiler version intended by the original authors. // bad pragma solidity ^ 0.4 . 4 ; // good pragma solidity 0.4 . 4 ; Note: a floating pragma version (ie. ^0.4.25 ) will compile fine with 0.4.26-nightly.2018.9.25 , however nightly builds should never be used to compile code for production. Warning Pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally. See SWC-103","title":"Locking Pragmas"},{"location":"development-recommendations/solidity-specific/modifiers-as-guards/","text":"The code inside a modifier is usually executed before the function body, so any state changes or external calls will violate the Checks-Effects-Interactions pattern. Moreover, these statements may also remain unnoticed by the developer, as the code for modifier may be far from the function declaration. For example, an external call in modifier can lead to the reentrancy attack: contract Registry { address owner ; function isVoter ( address _addr ) external returns ( bool ) { // Code } } contract Election { Registry registry ; modifier isEligible ( address _addr ) { require ( registry . isVoter ( _addr )); _ ; } function vote () isEligible ( msg.sender ) public { // Code } } In this case, the Registry contract can make a reentrancy attack by calling Election.vote() inside isVoter() . Note Use modifiers to replace duplicate condition checks in multiple functions, such as isOwner() , otherwise use require or revert inside the function. This makes your smart contract code more readable and easier to audit.","title":"Modifiers as Guards"},{"location":"development-recommendations/solidity-specific/payability/","text":"Starting from Solidity 0.4.0 , every function that is receiving ether must use payable modifier, otherwise if the transaction has msg.value > 0 will revert ( except when forced ). Note Something that might not be obvious: The payable modifier only applies to calls from external contracts. If I call a non-payable function in the payable function in the same contract, the non-payable function won't fail, though msg.value is still set.","title":"Payability"},{"location":"development-recommendations/solidity-specific/shadowing/","text":"It is currently possible to shadow built-in globals in Solidity. This allows contracts to override the functionality of built-ins such as msg and revert() . Although this is intended , it can mislead users of a contract as to the contract's true behavior. contract PretendingToRevert { function revert () internal constant {} } contract ExampleContract is PretendingToRevert { function somethingBad () public { revert (); } } Contract users (and auditors) should be aware of the full smart contract source code of any application they intend to use.","title":"Shadowing"},{"location":"development-recommendations/solidity-specific/timestamp-dependence/","text":"There are three main considerations when using a timestamp to execute a critical function in a contract, especially when actions involve fund transfer. Timestamp Manipulation \u00b6 Be aware that the timestamp of the block can be manipulated by a miner. Consider this contract : uint256 constant private salt = block.timestamp ; function random ( uint Max ) constant private returns ( uint256 result ){ //get the best seed for randomness uint256 x = salt * 100 / Max ; uint256 y = salt * block.number / ( salt % 5 ) ; uint256 seed = block.number / 3 + ( salt % 300 ) + Last_Payout + y ; uint256 h = uint256 ( block.blockhash ( seed )); return uint256 (( h / x )) % Max + 1 ; //random number between 1 and Max } When the contract uses the timestamp to seed a random number, the miner can actually post a timestamp within 15 seconds of the block being validated, effectively allowing the miner to precompute an option more favorable to their chances in the lottery. Timestamps are not random and should not be used in that context. The 15-second Rule \u00b6 The Yellow Paper (Ethereum's reference specification) does not specify a constraint on how much blocks can drift in time, but it does specify that each timestamp should be bigger than the timestamp of its parent. Popular Ethereum protocol implementations Geth and Parity both reject blocks with timestamp more than 15 seconds in future. Therefore, a good rule of thumb in evaluating timestamp usage is: Note If the scale of your time-dependent event can vary by 15 seconds and maintain integrity, it is safe to use a block.timestamp . Avoid using block.number as a timestamp \u00b6 It is possible to estimate a time delta using the block.number property and average block time , however this is not future proof as block times may change (such as fork reorganisations and the difficulty bomb ). In a sale spanning days, the 15-second rule allows one to achieve a more reliable estimate of time. See SWC-116","title":"Timestamp Dependence"},{"location":"development-recommendations/solidity-specific/timestamp-dependence/#timestamp-manipulation","text":"Be aware that the timestamp of the block can be manipulated by a miner. Consider this contract : uint256 constant private salt = block.timestamp ; function random ( uint Max ) constant private returns ( uint256 result ){ //get the best seed for randomness uint256 x = salt * 100 / Max ; uint256 y = salt * block.number / ( salt % 5 ) ; uint256 seed = block.number / 3 + ( salt % 300 ) + Last_Payout + y ; uint256 h = uint256 ( block.blockhash ( seed )); return uint256 (( h / x )) % Max + 1 ; //random number between 1 and Max } When the contract uses the timestamp to seed a random number, the miner can actually post a timestamp within 15 seconds of the block being validated, effectively allowing the miner to precompute an option more favorable to their chances in the lottery. Timestamps are not random and should not be used in that context.","title":"Timestamp Manipulation"},{"location":"development-recommendations/solidity-specific/timestamp-dependence/#the-15-second-rule","text":"The Yellow Paper (Ethereum's reference specification) does not specify a constraint on how much blocks can drift in time, but it does specify that each timestamp should be bigger than the timestamp of its parent. Popular Ethereum protocol implementations Geth and Parity both reject blocks with timestamp more than 15 seconds in future. Therefore, a good rule of thumb in evaluating timestamp usage is: Note If the scale of your time-dependent event can vary by 15 seconds and maintain integrity, it is safe to use a block.timestamp .","title":"The 15-second Rule"},{"location":"development-recommendations/solidity-specific/timestamp-dependence/#avoid-using-blocknumber-as-a-timestamp","text":"It is possible to estimate a time delta using the block.number property and average block time , however this is not future proof as block times may change (such as fork reorganisations and the difficulty bomb ). In a sale spanning days, the 15-second rule allows one to achieve a more reliable estimate of time. See SWC-116","title":"Avoid using block.number as a timestamp"},{"location":"development-recommendations/solidity-specific/tx-origin/","text":"Never use tx.origin for authorization, another contract can have a method which will call your contract (where the user has some funds for instance) and your contract will authorize that transaction as your address is in tx.origin . contract MyContract { address owner ; function MyContract () public { owner = msg.sender ; } function sendTo ( address receiver , uint amount ) public { require ( tx.origin == owner ); ( bool success , ) = receiver . call . value ( amount )( \"\" ); require ( success ); } } contract AttackingContract { MyContract myContract ; address attacker ; function AttackingContract ( address myContractAddress ) public { myContract = MyContract ( myContractAddress ); attacker = msg.sender ; } function () public { myContract . sendTo ( attacker , msg.sender . balance ); } } You should use msg.sender for authorization (if another contract calls your contract msg.sender will be the address of the contract and not the address of the user who called the contract). You can read more about it here: Solidity docs Warning Besides the issue with authorization, there is a chance that tx.origin will be removed from the Ethereum protocol in the future, so code that uses tx.origin won't be compatible with future releases Vitalik: 'Do NOT assume that tx.origin will continue to be usable or meaningful.' It's also worth mentioning that by using tx.origin you're limiting interoperability between contracts because the contract that uses tx.origin cannot be used by another contract as a contract can't be the tx.origin . See SWC-115","title":"tx.origin"},{"location":"development-recommendations/solidity-specific/visibility/","text":"Explicitly label the visibility of functions and state variables. Functions can be specified as being external , public , internal or private . Please understand the differences between them, for example, external may be sufficient instead of public . For state variables, external is not possible. Labeling the visibility explicitly will make it easier to catch incorrect assumptions about who can call the function or access the variable. External functions are part of the contract interface. An external function f cannot be called internally (i.e. f() does not work, but this.f() works). External functions are sometimes more efficient when they receive large arrays of data. Public functions are part of the contract interface and can be either called internally or via messages. For public state variables, an automatic getter function (see below) is generated. Internal functions and state variables can only be accessed internally, without using this . Private functions and state variables are only visible for the contract they are defined in and not in derived contracts. Note : Everything that is inside a contract is visible to all observers external to the blockchain, even Private variables. * // bad uint x ; // the default is internal for state variables, but it should be made explicit function buy () { // the default is public // public code } // good uint private y ; function buy () external { // only callable externally or using this.buy() } function utility () public { // callable externally, as well as internally: changing this code requires thinking about both cases. } function internalAction () internal { // internal code } See SWC-100 and SWC-108","title":"Visibility"},{"location":"development-recommendations/token-specific/contract-address/","text":"Consider also preventing the transfer of tokens to the same address of the smart contract. An example of the potential for loss by leaving this open is the EOS token smart contract where more than 90,000 tokens are stuck at the contract address. Example \u00b6 An example of implementing both the above recommendations would be to create the following modifier; validating that the \"to\" address is neither 0x0 nor the smart contract's own address: modifier validDestination ( address to ) { require ( to != address ( 0x0 )); require ( to != address ( this ) ); _ ; } The modifier should then be applied to the \"transfer\" and \"transferFrom\" methods: function transfer ( address _to , uint _value ) validDestination ( _to ) returns ( bool ) { (... your logic ...) } function transferFrom ( address _from , address _to , uint _value ) validDestination ( _to ) returns ( bool ) { (... your logic ...) }","title":"Contract Address"},{"location":"development-recommendations/token-specific/contract-address/#example","text":"An example of implementing both the above recommendations would be to create the following modifier; validating that the \"to\" address is neither 0x0 nor the smart contract's own address: modifier validDestination ( address to ) { require ( to != address ( 0x0 )); require ( to != address ( this ) ); _ ; } The modifier should then be applied to the \"transfer\" and \"transferFrom\" methods: function transfer ( address _to , uint _value ) validDestination ( _to ) returns ( bool ) { (... your logic ...) } function transferFrom ( address _from , address _to , uint _value ) validDestination ( _to ) returns ( bool ) { (... your logic ...) }","title":"Example"},{"location":"development-recommendations/token-specific/frontrunning/","text":"The EIP-20 token's approve() function creates the potential for an approved spender to spend more than the intended amount. A front running attack can be used, enabling an approved spender to call transferFrom() both before and after the call to approve() is processed. More details are available on the EIP , and in this document .","title":"Frontrunning"},{"location":"development-recommendations/token-specific/standardization/","text":"Generally speaking, smart contracts of tokens should follow an accepted and stable standard. Examples of currently accepted standards include: EIP20 EIP721 (non-fungible token) More at eips.ethereum.org","title":"Standardization"},{"location":"development-recommendations/token-specific/zero-address/","text":"At the time of writing, the \"zero\" address ( 0x0000000000000000000000000000000000000000 ) holds tokens with a value of more than 80$ million.","title":"Zero Address"},{"location":"general-philosophy/","text":"Ethereum and complex blockchain programs are new and highly experimental. Therefore, you should expect constant changes in the security landscape, as new bugs and security risks are discovered, and new best practices are developed. Following the security practices in this document is therefore only the beginning of the security work you will need to do as a smart contract developer. Smart contract programming requires a different engineering mindset than you may be used to. The cost of failure can be high, and change can be difficult, making it in some ways more similar to hardware programming or financial services programming than web or mobile development. It is therefore not enough to defend against known vulnerabilities. Instead, you will need to learn a new philosophy of development:","title":"Index"},{"location":"general-philosophy/blockchain-properties/","text":"While much of your programming experience will be relevant to Ethereum programming, there are some pitfalls to be aware of. Be extremely careful about external contract calls, which may execute malicious code and change control flow. Understand that your public functions are public, and may be called maliciously and in any order. The private data in smart contracts is also viewable by anyone. Keep gas costs and the block gas limit in mind. Be aware that timestamps are imprecise on a blockchain, miners can influence the time of execution of a transaction within a margin of several seconds. Randomness is non-trivial on blockchain, most approaches to random number generation are gameable on a blockchain.","title":"Blockchain Properties"},{"location":"general-philosophy/prepare-for-failure/","text":"Any non-trivial contract will have errors in it. Your code must, therefore, be able to respond to bugs and vulnerabilities gracefully. Pause the contract when things are going wrong ('circuit breaker') Manage the amount of money at risk (rate limiting, maximum usage) Have an effective upgrade path for bugfixes and improvements","title":"Prepare for Failure"},{"location":"general-philosophy/rollout/","text":"It is always better to catch bugs before a full production release. Test contracts thoroughly, and add tests whenever new attack vectors are discovered Provide bug bounties starting from alpha testnet releases Rollout in phases, with increasing usage and testing in each phase","title":"Rolling out"},{"location":"general-philosophy/simplicity-vs-complexity/","text":"There are multiple fundamental tradeoffs to consider when assessing the structure and security of a smart contract system. The general recommendation for any smart contract system is to identify the proper balance for these fundamental tradeoffs. An ideal smart contract system from a software engineering bias is modular, reuses code instead of duplicating it, and supports upgradeable components. An ideal smart contract system from a secure architecture bias may share this mindset, especially in the case of more complex smart contract systems. However, there are important exceptions where security and software engineering best practices may not be aligned. In each case, the proper balance is obtained by identifying the optimal mix of properties along contract system dimensions such as: Rigid versus Upgradeable Monolithic versus Modular Duplication versus Reuse Rigid versus Upgradeable \u00b6 While multiple resources, including this one, emphasize malleability characteristics such as Killable, Upgradeable or Modifiable patterns there is a fundamental tradeoff between malleability and security. Malleability patterns by definition add complexity and potential attack surfaces. Simplicity is particularly effective over complexity in cases where the smart contract system performs a very limited set of functionality for a pre-defined limited period of time, for example, a governance-free finite-time-frame token-sale contract system. Monolithic versus Modular \u00b6 A monolithic self-contained contract keeps all knowledge locally identifiable and readable. While there are few smart contract systems held in high regard that exist as monoliths, there is an argument to be made for extreme locality of data and flow - for example, in the case of optimizing code review efficiency. As with the other tradeoffs considered here, security best practices trend away from software engineering best practices in simple short-lived contracts and trend toward software engineering best practices in the case of more complex perpetual contract systems. Duplication versus Reuse \u00b6 A smart contract system from a software engineering perspective wishes to maximize reuse where reasonable. There are many ways to reuse contract code in Solidity. Using proven previously-deployed contracts which you own is generally the safest manner to achieve code reuse. Duplication is frequently relied upon in cases where self-owned previously-deployed contracts are not available. Efforts such as OpenZeppelin's Solidity Library seek to provide patterns such that secure code can be re-used without duplication. Any contract security analysis must include any re-used code that has not previously established a level of trust commensurate with the funds at risk in the target smart contract system.","title":"Simplicity vs. Complexity"},{"location":"general-philosophy/simplicity-vs-complexity/#rigid-versus-upgradeable","text":"While multiple resources, including this one, emphasize malleability characteristics such as Killable, Upgradeable or Modifiable patterns there is a fundamental tradeoff between malleability and security. Malleability patterns by definition add complexity and potential attack surfaces. Simplicity is particularly effective over complexity in cases where the smart contract system performs a very limited set of functionality for a pre-defined limited period of time, for example, a governance-free finite-time-frame token-sale contract system.","title":"Rigid versus Upgradeable"},{"location":"general-philosophy/simplicity-vs-complexity/#monolithic-versus-modular","text":"A monolithic self-contained contract keeps all knowledge locally identifiable and readable. While there are few smart contract systems held in high regard that exist as monoliths, there is an argument to be made for extreme locality of data and flow - for example, in the case of optimizing code review efficiency. As with the other tradeoffs considered here, security best practices trend away from software engineering best practices in simple short-lived contracts and trend toward software engineering best practices in the case of more complex perpetual contract systems.","title":"Monolithic versus Modular"},{"location":"general-philosophy/simplicity-vs-complexity/#duplication-versus-reuse","text":"A smart contract system from a software engineering perspective wishes to maximize reuse where reasonable. There are many ways to reuse contract code in Solidity. Using proven previously-deployed contracts which you own is generally the safest manner to achieve code reuse. Duplication is frequently relied upon in cases where self-owned previously-deployed contracts are not available. Efforts such as OpenZeppelin's Solidity Library seek to provide patterns such that secure code can be re-used without duplication. Any contract security analysis must include any re-used code that has not previously established a level of trust commensurate with the funds at risk in the target smart contract system.","title":"Duplication versus Reuse"},{"location":"general-philosophy/simplicity/","text":"Complexity increases the likelihood of errors. Ensure the contract logic is simple Modularize code to keep contracts and functions small Use already-written tools or code where possible (eg. don't roll your own random number generator) Prefer clarity to performance whenever possible Only use the blockchain for the parts of your system that require decentralization","title":"Keep it Simple"},{"location":"general-philosophy/stay-up-to-date/","text":"Keep track of new security developments. Check your contracts for any new bug as soon as it is discovered Upgrade to the latest version of any tool or library as soon as possible Adopt new security techniques that appear useful","title":"Stay up to Date"},{"location":"security-tools/","text":"This section is about tools that can detect vulnerabilities or help developers maintain a high code quality to reduce the likelihood and impact of vulnerabilities. Category Description Visualization These tools are aimed at visualizing, EVM bytecode, smart contracts, and their control flow graphs. Static and Dynamic Analysis Tools that employ various means of program analysis to find vulnabilities and weaknesses. Classification Resources attempting to classify vulnerabilities and weaknesses in smart contracts. Testing Tools for running, measuring, and managing smart contract related tests Linters and Formatters Any tools that highlight code smells and make smart contract code adhere to format standards.","title":"Index"},{"location":"security-tools/classification/","text":"SWC-registry - SWC definitions and a large repository of crafted and real-world samples of vulnerable smart contracts. SWC Pages - The SWC-registry repo published on Github Pages","title":"Classification"},{"location":"security-tools/linters-and-formatters/","text":"Linters improve code quality by enforcing rules for style and composition, making code easier to read and review. Ethlint - Yet another Solidity linting. Solhint - A linter for Solidity that provides both Security and Style Guide validations. Prettier + Solidity Plugin - Prettier enforces basic style conventions in your code.","title":"Linters and Formatters"},{"location":"security-tools/static-and-dynamic-analysis/","text":"MythX - MythX is a professional-grade cloud service that uses symbolic analysis and input fuzzing to detect common security bugs and verify the correctness of smart contract code . Using MythX requires an API key from mythx.io . Mythril - The Swiss army knife for smart contract security. Slither - Static analysis framework with detectors for many common Solidity issues. It has taint and value tracking capabilities and is written in Python. Contract-Library - Decompiler and security analysis tool for all deployed contracts. MadMax - Static analysis tool for gas DoS vulnerabilities. Gigahorse - Fast binary lifter and program analysis framework written in Datalog. Echidna - The only available fuzzer for Ethereum software. Uses property testing to generate malicious inputs that break smart contracts. Manticore - Dynamic binary analysis tool with EVM support . Oyente - Analyze Ethereum code to find common vulnerabilities, based on this paper . Securify - Fully automated online static analyzer for smart contracts, providing a security report based on vulnerability patterns. SmartCheck - Static analysis of Solidity source code for security vulnerabilities and best practices. Octopus - Security Analysis tool for Blockchain Smart Contracts with support of EVM and (e)WASM. sFuzz - Efficient fuzzer inspired from AFL to find common vulnerabilities. Vertigo - Mutation Testing for Ethereum Smart Contracts.","title":"Static and Dynamic Analysis"},{"location":"security-tools/testing/","text":"solidity-coverage - Code coverage for Solidity testing.","title":"Testing"},{"location":"security-tools/visualization/","text":"Solidity Visual Auditor - This extension contributes security centric syntax and semantic highlighting, a detailed class outline and advanced Solidity code insights to Visual Studio Code S\u016brya - Utility tool for smart contract systems, offering a number of visual outputs and information about the contracts' structure. Also supports querying the function call graph. Solgraph - Generates a DOT graph that visualizes function control flow of a Solidity contract and highlights potential security vulnerabilities. EVM Lab - Rich tool package to interact with the EVM. Includes a VM, Etherchain API, and a trace-viewer. ethereum-graph-debugger - A graphical EVM debugger. Displays the entire program control flow graph. Piet - Web application helping understand smart contract architectures. Offers graphical representation and inspection of smart contracts as well as a markdown documentation generator.","title":"Visualization"}]}